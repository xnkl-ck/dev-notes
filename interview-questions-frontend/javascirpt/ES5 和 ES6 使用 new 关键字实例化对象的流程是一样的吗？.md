## 前言

JavaScript 中，`new` 关键字是创建对象实例的重要工具。随着 ES6 的引入，新增了 `class` 语法，很多人会疑问：ES5 时代使用构造函数配合 `new` 和 ES6 中用 `class` 结合 `new`，二者实例化流程是否相同？本文将详细比较二者的执行流程，帮助理解 ES6 `class` 的本质。

## ES5 使用构造函数和 new 的实例化流程

在 ES5 及以前，实例化对象通常是通过构造函数配合 `new` 关键字完成的。其流程包括：

- 创建一个新对象，并将其 `[[Prototype]]` 指向构造函数的 `prototype`
- 执行构造函数，`this` 指向新对象
- 构造函数隐式返回新对象（除非显式返回其他对象）

此时，实例对象继承了构造函数原型上的属性和方法。

## ES6 使用 class 和 new 的实例化流程

ES6 `class` 的本质仍是基于函数和原型链的语法糖，其实例化流程在本质上与 ES5 构造函数类似，但有一些额外的限制和增强：

- 不能在未调用 `new` 的情况下执行类构造函数，否则报错
- 类内部默认使用严格模式，确保更安全的语法行为
- 类的 `constructor` 必须调用 `super()`（如果有继承），否则会报错
- 方法定义在类的 `prototype` 上，且不可枚举

实例化过程步骤：

- 创建实例对象，原型指向类的 `prototype`
- 绑定 `this` 执行构造函数（`constructor` 方法）
- 返回实例对象或构造函数显式返回的对象

## 主要差异点

- **严格模式默认开启**
  ES6 class 内部代码自动启用严格模式，ES5 构造函数默认非严格。
- **调用限制**
  ES6 class 必须通过 `new` 调用，否则抛错；ES5 构造函数没有强制要求。
- **继承机制**
  ES6 class 支持内置 `extends` 和 `super` 关键字，简化继承链调用，ES5 需手动设置原型链和调用父构造函数。
- **方法定义特性**
  ES6 class 中方法默认不可枚举，ES5 构造函数原型方法可枚举。
- **语法和语义更规范**
  ES6 class 语法更接近传统面向对象语言。

## 总结

从实例化流程核心步骤看，ES5 和 ES6 使用 `new` 的对象创建机制是相同的：都是创建新对象、绑定 `this`、执行构造函数、返回对象。差异主要体现在 ES6 class 语法的限制、安全性和继承机制等方面。ES6 class 本质上是 ES5 构造函数的语法糖和规范化提升。

------

## 面试回答示范

**问题：ES5 和 ES6 使用 new 关键字实例化对象的流程是一样的吗？**

回答示例：

“它们在底层实例化流程上是相同的，都会先创建一个新对象，将其原型指向构造函数（或类）的 `prototype`，然后执行构造函数体并绑定 `this`，最后返回新对象。不同之处是，ES6 class 强制必须用 `new` 调用，且内部默认严格模式，支持更方便的继承和语法规范。”