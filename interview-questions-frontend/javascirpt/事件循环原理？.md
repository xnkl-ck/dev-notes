# **事件循环原理？**

## 前言

JavaScript 是单线程语言，但它能够高效处理异步任务，关键在于事件循环机制。事件循环（Event Loop）协调调用栈与任务队列，保证异步任务的执行顺序。深入理解事件循环，有助于准确把握异步编程、性能优化和调试技巧。

本文详细讲解事件循环的工作原理、任务队列分类及其对代码执行的影响。

## 事件循环的基本结构

事件循环涉及以下几个核心概念：

- **调用栈（Call Stack）**：存放当前执行的函数，遵循先进后出原则。
- **任务队列（Task Queue）**：存储等待执行的异步回调任务。
- **消息队列**：任务队列的一种，保存来自异步事件的回调。
- **微任务队列（Microtask Queue）**：存放 Promise 的回调和 MutationObserver 的回调。
- **事件循环（Event Loop）**：不断检测调用栈是否为空，若为空则从任务队列取任务执行。

## 事件循环执行流程

1. 主线程执行同步代码，调用栈不断入栈和出栈。
2. 遇到异步操作时（如定时器、网络请求），异步任务交给浏览器或 Node.js 的后台环境处理，主线程继续执行同步代码。
3. 异步操作完成后，将对应回调放入任务队列或微任务队列。
4. 当前调用栈为空时，事件循环优先执行微任务队列中的任务，直到队列清空。
5. 微任务清空后，事件循环再从宏任务队列（Task Queue）中取出一个任务执行。
6. 任务执行完毕，重复以上过程。

这个循环保证了异步任务的有序执行，同时维持主线程的非阻塞。

## 宏任务与微任务区别

- **宏任务（Macrotask）**包括：`setTimeout`、`setInterval`、`setImmediate`（Node.js）、I/O、UI 渲染等。
- **微任务（Microtask）**包括：`Promise.then/catch/finally`、`process.nextTick`（Node.js）、`MutationObserver`。

事件循环中，微任务的优先级高于宏任务，即每轮事件循环先执行所有微任务，再执行一个宏任务。

## 示例说明

```plain
console.log('script start');

setTimeout(() => {
  console.log('setTimeout');
}, 0);

Promise.resolve().then(() => {
  console.log('promise1');
}).then(() => {
  console.log('promise2');
});

console.log('script end');
```

输出顺序：

```plain
script start
script end
promise1
promise2
setTimeout
```

解释：

- 同步代码先执行。
- Promise 的回调进入微任务队列，优先执行。
- `setTimeout` 回调进入宏任务队列，微任务执行完后才执行。

## 事件循环中的渲染

浏览器事件循环还涉及页面渲染，每轮宏任务执行完成后，浏览器会触发渲染刷新。长时间阻塞主线程会导致界面卡顿。

合理利用事件循环机制，可以避免阻塞，提升用户体验。

## 面试回答

事件循环是 JavaScript 处理异步的核心机制。它协调调用栈和任务队列，保证代码按顺序执行。

执行同步代码时，调用栈不断执行函数。遇到异步操作，主线程继续执行，异步任务由浏览器或 Node.js 处理，完成后将回调放入任务队列。

事件循环不断检查调用栈，若为空，优先执行微任务队列中所有任务，再执行宏任务队列的一个任务。宏任务包括 `setTimeout`、I/O，微任务包括 Promise 的回调。

这种机制保证了微任务比宏任务优先执行，保证异步操作按预期顺序执行，并且不会阻塞主线程。

## 总结

事件循环是 JavaScript 异步模型的基石。它通过调用栈、宏任务队列和微任务队列协同工作，实现异步任务的有序执行。掌握事件循环原理，有利于优化异步代码，提升性能和用户体验。