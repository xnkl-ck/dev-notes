# **如何判断一个属性来自对象本身，还是来自原型链？**

## 前言

在 JavaScript 中，对象的属性可以直接定义在对象自身，也可以通过原型链继承而来。当我们访问某个属性时，引擎会先在对象本身查找，找不到才会沿原型链查找。了解属性的“归属”对调试代码、避免属性覆盖、判断继承关系非常重要。本文将讲清楚如何区分属性是定义在对象自身，还是继承自其原型链。

## 属性访问机制回顾

当访问对象的属性时，JavaScript 引擎会遵循如下查找路径：

1. 首先检查对象本身是否有这个属性（也就是对象自己的属性）
2. 如果没有，就查看对象的 `[[Prototype]]`，也就是它的原型对象
3. 再检查原型对象是否有该属性
4. 如果还没有，就继续往上查找，直到 `Object.prototype`
5. 若整个原型链都没有该属性，返回 `undefined`

这个查找路径就是所谓的“原型链”。

例子：

```javascript
function Person(name) {
  this.name = name;
}
Person.prototype.sayHello = function () {
  console.log('Hello');
};

const p = new Person('Alice');
```

`p.name` 是实例自身的属性，`p.sayHello` 是继承自原型。

## 如何判断属性来源

### 使用 hasOwnProperty

最常用、最权威的方式是使用 `hasOwnProperty()` 方法判断某个属性是否为对象自身的属性。

```javascript
p.hasOwnProperty('name'); // true
p.hasOwnProperty('sayHello'); // false
```

该方法只返回对象“自有属性”，不会检查原型链。

### 使用 in 操作符配合 hasOwnProperty

`in` 可以判断属性是否存在于对象自身或原型链中。

```javascript
'name' in p;       // true
'sayHello' in p;   // true
'toString' in p;   // true
'age' in p;        // false
```

但如果你想判断某属性是“存在”且“来自自身”，必须同时结合：

```javascript
if ('sayHello' in p && !p.hasOwnProperty('sayHello')) {
  console.log('sayHello 来自原型');
}
```

### 遍历时注意点

使用 `for...in` 遍历对象时，默认会包含原型链上的可枚举属性。可以用 `Object.keys()` 或 `Object.getOwnPropertyNames()` 只获取自身属性。

```javascript
for (let key in p) {
  if (p.hasOwnProperty(key)) {
    console.log(key + ' 是自身属性');
  } else {
    console.log(key + ' 是继承属性');
  }
}
```

------

## 面试回答示范

**问题：如何判断一个属性来自对象本身还是原型链？**

回答示例：

“可以使用 `hasOwnProperty()` 方法判断某个属性是否属于对象自身，它只会返回对象直接拥有的属性而不会查原型链。如果返回 `false`，说明这个属性可能来自原型链上的某个对象。

例如：

```javascript
obj.hasOwnProperty('prop') // true 表示是自身属性，false 表示可能是继承来的
```

如果还想判断该属性是否存在但是继承的，可以结合 `in` 操作符一起判断。”

------

## 总结

掌握属性来源的判断方法，是理解 JavaScript 原型机制的重要一步。无论是为了避免属性冲突，还是优化代码结构，我们都应该熟练运用 `hasOwnProperty()` 来识别属性归属。更进一步地，可以通过组合 `in` 操作符和属性遍历工具，构建更健壮的对象处理逻辑。