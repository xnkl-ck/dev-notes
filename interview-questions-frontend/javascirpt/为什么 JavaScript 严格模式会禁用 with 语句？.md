# **为什么 JavaScript 严格模式会禁用 with 语句？**

## 前言

在 JavaScript 中，`with` 是一个被认为“危险”的语法结构，它允许你临时扩展作用域链，在某些早期代码中常被用于简化对象属性访问。然而在 ES5 的严格模式下，`with` 被完全禁用了。这一禁用背后反映了 JavaScript 对语法可预测性、安全性与性能的权衡。本文将深入剖析 `with` 的本质、使用带来的问题，以及为何它与严格模式不兼容。

## with 是什么？

`with` 是 JavaScript 提供的一个语法结构，用来将一个对象临时加入作用域链，使得访问该对象的属性时可以省略前缀。

示例：

```javascript
const obj = { a: 1, b: 2 };
with (obj) {
  console.log(a); // 输出 1，相当于 obj.a
}
```

虽然看起来很方便，但 `with` 语句会**动态修改作用域链**，从而引发一系列不可预知的问题。

## 禁用 with 的核心原因

### 一、破坏作用域静态解析

JavaScript 引擎在编译阶段会做静态作用域分析，比如变量是否声明、作用域绑定等。而 `with` 引入的是**动态作用域扩展**，让变量查找变得模糊不清。

如下代码：

```javascript
const obj = { a: 1 };
function test() {
  const a = 2;
  with (obj) {
    console.log(a);
  }
}
```

到底输出的是 `obj.a` 还是函数作用域内的 `a`？这个答案需要等到运行时才能确认，完全取决于对象是否包含 `a`。这严重破坏了静态分析的可能性。

### 二、带来性能开销

现代 JS 引擎会对作用域链做各种优化，比如作用域提升、变量缓存等，但 `with` 动态引入新的作用域会使优化机制失效。引擎无法预测变量查找路径，影响执行效率。

为了安全和性能考虑，V8 等引擎对使用 `with` 的代码执行路径做了保守处理，导致这些代码性能很差。

### 三、代码可读性差

`with` 让变量引用来源不清晰，极易造成误判或隐式错误。比如：

```javascript
with (obj) {
  foo = 42;
}
```

`foo` 是 `obj.foo` 还是全局变量？这取决于 `obj` 是否定义了 `foo`，而这一行为并不显式，增加了维护难度。

### 四、与严格模式目标相悖

严格模式的目标是让代码行为更清晰、更规范、更安全，而 `with` 恰恰走的是反方向。为了防止混淆和不确定性，严格模式直接禁止使用 `with`。

如果在严格模式下使用 `with`，JavaScript 会在语法解析阶段直接报错，阻止代码执行。

------

## 面试回答示范

**问题：为什么严格模式中禁止使用** `with`**？**

回答示例：

“严格模式禁止使用 `with`，主要是因为它破坏了作用域链的静态性，使得变量查找在运行时变得不可预测。这样会干扰 JavaScript 引擎的优化逻辑，也让代码的可读性和可维护性变差。

严格模式的目标是让代码行为更清晰和可控，而 `with` 带来的不确定性正好与此相反，所以它被完全禁用了。我在实际开发中也不会使用 `with`，因为它会增加代码出错的概率。”

------

## 总结

`with` 看似便捷，实则是 JavaScript 中一个“陷阱”级语法，它模糊了作用域边界，引发变量解析歧义，影响性能与可读性。正因如此，严格模式选择了禁用它，以推动更规范和安全的开发方式。在现代 JavaScript 开发中，我们应完全避免使用 `with`，即便不是在严格模式下。