# **解构复制对象，是深拷贝还是浅拷贝？**

## 前言

在 JavaScript 中，对象的复制行为是开发中的常见话题，特别是在使用解构赋值时。许多开发者容易混淆解构复制是深拷贝还是浅拷贝。本文将详细解释解构复制的本质，帮助你正确理解和应用复制技术。

## 解构复制的基本原理

解构赋值是一种简洁的语法，用于从对象或数组中提取值。在复制对象时，解构实际上是对对象的**浅拷贝**。

浅拷贝指的是复制对象的第一层属性，如果属性是基本类型，则复制值；如果是引用类型，则复制的是引用地址。

示例：

```plain
const obj1 = { a: 1, b: { c: 2 } };
const obj2 = { ...obj1 };  // 通过解构复制
obj2.a = 10;
obj2.b.c = 20;

console.log(obj1.a);  // 1，基本类型属性是独立的
console.log(obj1.b.c); // 20，引用类型属性指向同一对象，修改影响原对象
```

从示例可以看出，`obj2` 对象中 `a` 属性是独立复制的，`b` 属性仍然指向 `obj1.b` 的同一个对象。

## 深拷贝与浅拷贝区别

- **浅拷贝**
  复制对象的第一层属性，嵌套的对象仍是引用。
- **深拷贝**
  递归复制所有层级的对象，完全独立，修改任何层级不会影响原对象。

深拷贝通常需要借助专门函数，如 `JSON.parse(JSON.stringify(obj))`，或者第三方库（如 lodash 的 `cloneDeep`），以及手写递归函数。

## 解构复制的限制和注意事项

- 不能复制对象的非可枚举属性和 Symbol 属性。
- 无法复制对象的方法和原型链。
- 不会复制对象的 getter/setter。
- 可能导致循环引用拷贝失败。

## 总结应用场景

解构复制适合快速创建对象浅层副本，适用于简单对象或对嵌套引用无修改需求的场景。复杂对象则建议使用深拷贝。

------

## 面试回答示范

**问题：用解构复制对象，是深拷贝还是浅拷贝？**

回答示例：

“解构复制其实是一种浅拷贝操作。它只复制对象的第一层属性，对于基本类型会复制值，对于引用类型复制的是引用地址，导致嵌套对象仍共享同一内存。如果需要完全独立的副本，应该使用深拷贝方法，比如 JSON 序列化或者第三方库。解构复制简单高效，但要注意它不能复制函数、原型链和不可枚举属性。”

------

## 总结

清晰区分浅拷贝与深拷贝，了解解构复制的行为限制，能帮助开发者避免对象引用混乱和数据污染，写出更加健壮的代码。