# **如何检测对象是否存在循环引用？**

## 前言

在 JavaScript 中，循环引用（循环依赖）是指对象内部存在相互引用，形成闭环的情况。比如对象 A 引用对象 B，B 又引用 A，这样就会导致无限递归问题，给序列化（如 JSON.stringify）、深拷贝等操作带来困难。准确检测循环引用，是避免程序崩溃和内存泄漏的重要环节。本文将详细介绍检测循环引用的思路和方法。

## 循环引用产生的原因及危害

循环引用通常发生在复杂数据结构中，例如树状或图结构，或者父子对象相互持有引用。其主要问题：

- `JSON.stringify` 会抛出异常 `TypeError: Converting circular structure to JSON`
- 深拷贝若不处理循环，会导致死循环或栈溢出
- 内存泄漏，导致垃圾回收无法正常回收相关对象

## 检测循环引用的基本思路

核心在于遍历对象属性时，记录访问过的对象引用，如果再次访问到已记录的对象，则说明存在循环引用。

## 常用检测实现示例

以下是基于递归和 WeakSet（弱引用集合）实现的检测函数：

```plain
function hasCircularReference(obj, seen = new WeakSet()) {
  if (obj && typeof obj === 'object') {
    if (seen.has(obj)) {
      return true; // 找到循环引用
    }
    seen.add(obj);
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        if (hasCircularReference(obj[key], seen)) {
          return true;
        }
      }
    }
  }
  return false;
}
```

使用示例：

```plain
const a = {};
const b = { a };
a.b = b;

console.log(hasCircularReference(a)); // true
```

此方法递归遍历所有对象属性，并利用 WeakSet 记录访问过的对象，避免内存泄漏。

## 其他检测方案

- **非递归方式**：使用栈或队列遍历，但逻辑复杂度较高。
- **第三方库**：如 `circular-json`、`flatted` 等可自动处理循环引用的序列化。
- **深拷贝工具**：例如 lodash 的 `cloneDeepWith` 也内置循环引用检测。

## 注意点

- WeakSet 只能存储对象引用，基本类型不用存储。
- 检测性能与对象大小和深度相关，大对象递归较慢。
- 函数、Symbol 类型属性通常可忽略或视具体业务处理。

------

## 面试回答示范

**问题：如何检测一个对象是否有循环引用？**

回答示例：

“检测循环引用的关键是递归遍历对象属性，利用一个数据结构（如 WeakSet）记录已经访问过的对象引用。如果递归过程中再次遇到已访问的对象，说明存在循环引用。

具体实现时，可编写递归函数，传入 WeakSet 作为辅助存储，每遍历一个对象就加入 WeakSet，遍历其属性时若发现已存在则返回 true。”

------

## 总结

循环引用是复杂对象结构中常见的难题，合理检测能避免序列化和深拷贝时的错误。利用递归遍历结合 WeakSet 记录访问过的对象，是一种简单高效且不会导致内存泄漏的检测方式。理解这一机制，有助于提升代码健壮性和调试效率。