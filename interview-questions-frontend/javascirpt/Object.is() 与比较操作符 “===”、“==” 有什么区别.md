# **Object.is() 与比较操作符 “===”、“==” 有什么区别**

## 前言

JavaScript 中进行值比较时，常用的操作符有严格相等运算符（`===`）、抽象相等运算符（`==`），还有 ES6 引入的 `Object.is()` 方法。它们表面上都用于比较，但具体行为和语义上存在细微差异。本文详细剖析三者的区别及各自适用场景。

## 三者的基本区别

### 1. `==`（抽象相等运算符）

`==` 会在比较时进行类型转换（类型强制转换），然后再比较值。因为会自动转换，可能导致一些意料之外的结果。

示例：

```plain
0 == false;           // true
'' == 0;              // true
null == undefined;    // true
```

### 2. `===`（严格相等运算符）

`===` 不进行类型转换，要求类型和值都相同才返回 `true`。

示例：

```plain
0 === false;          // false
'' === 0;             // false
null === undefined;   // false
```

### 3. `Object.is()`

`Object.is()` 用于判断两个值是否严格相等，类似于 `===`，但有两处特殊：

- 区分 `+0` 和 `-0`，`Object.is(+0, -0)` 返回 `false`，而 `+0 === -0` 返回 `true`。
- 认为 `NaN` 和 `NaN` 是相等的，`Object.is(NaN, NaN)` 返回 `true`，而 `NaN === NaN` 返回 `false`。

示例：

```plain
Object.is(+0, -0);    // false
+0 === -0;            // true

Object.is(NaN, NaN);  // true
NaN === NaN;          // false
```

## 总结区别

- `==` 允许不同类型之间的转换比较，容易引发隐式类型转换错误，不推荐在严格代码中使用。
- `===` 要求类型和值完全相同，但把 `+0` 和 `-0` 视为相等，把 `NaN` 视为不等。
- `Object.is()` 适合需要区分 `+0`、`-0`，以及正确判断 `NaN` 相等的场景。

------

## 面试回答示范

**问题：Object.is() 与 “===”、“==” 有什么区别？**

回答示例：

“`==` 是抽象相等，会在比较前进行类型转换，所以可能出现意料之外的结果，通常不建议用。`===` 是严格相等，不做类型转换，只有类型和值都相同才返回真，但它把 `+0` 和 `-0` 视为相等，同时 `NaN` 和 `NaN` 视为不等。`Object.is()` 在行为上类似 `===`，但区别在于它区分 `+0` 和 `-0`，并且认为 `NaN` 和 `NaN` 是相等的，适合对这两种特殊情况有严格需求时使用。”

------

## 总结

理解三者的差异能帮助开发者正确选择比较方式，避免隐式类型转换带来的错误，提升代码的可靠性和准确性。