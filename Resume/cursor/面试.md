# 技术实现详解 - 完整技术手册

本文档是《面试准备-核心指南》的技术补充，包含所有项目的详细技术实现过程。

---

## 📚 目录

1. [AI 智能开发平台 - 技术实现](#1-ai-智能开发平台)
2. [AgentFactory - 技术实现](#2-agentfactory)
3. [河北银行系统 - 技术实现](#3-河北银行系统)
4. [友利银行系统 - 技术实现](#4-友利银行系统)
5. [技术深度问答](#5-技术深度问答)

---

## 1. AI 智能开发平台

### 1.1 RBAC 权限系统（70+ 权限）

#### 技术架构

```typescript
// 权限数据模型
interface Permission {
  id: string;
  code: string;              // 如 'dataset:create'
  name: string;
  module: string;            // 所属模块
  resource: string;          // 资源类型
  action: string;            // 操作类型
}

interface Role {
  id: string;
  name: string;
  tenantId: string;          // 多租户隔离
  permissions: Permission[];
  isSystem: boolean;         // 系统预设角色
}

interface UserRoleBinding {
  userId: string;
  roleIds: string[];
  tenantId: string;
}
```

#### 权限检查机制

**前端权限检查**：
```typescript
// hooks/use-permission.ts
export function usePermission() {
  const { user } = useAuth();
  
  const hasPermission = useCallback((permissionCode: string) => {
    if (!user?.permissions) return false;
    return user.permissions.some(p => p.code === permissionCode);
  }, [user]);
  
  const hasAnyPermission = useCallback((codes: string[]) => {
    return codes.some(code => hasPermission(code));
  }, [hasPermission]);
  
  const hasAllPermissions = useCallback((codes: string[]) => {
    return codes.every(code => hasPermission(code));
  }, [hasPermission]);
  
  return { hasPermission, hasAnyPermission, hasAllPermissions };
}

// 组件中使用
function DatasetActions() {
  const { hasPermission } = usePermission();
  
  return (
    <div className="actions">
      {hasPermission('dataset:create') && (
        <Button onClick={handleCreate}>创建数据集</Button>
      )}
      {hasPermission('dataset:delete') && (
        <Button onClick={handleDelete} variant="danger">删除</Button>
      )}
    </div>
  );
}
```

**路由级权限**：
```typescript
// middleware.ts
export async function middleware(request: NextRequest) {
  const token = request.cookies.get('token')?.value;
  
  // 验证 token
  const user = await verifyToken(token);
  if (!user) {
    return NextResponse.redirect(new URL('/login', request.url));
  }
  
  // 检查路由权限
  const pathname = request.nextUrl.pathname;
  const requiredPermission = getRoutePermission(pathname);
  
  if (requiredPermission && !user.permissions.includes(requiredPermission)) {
    return new Response('Forbidden', { status: 403 });
  }
  
  return NextResponse.next();
}

// 路由权限配置
const routePermissions: Record<string, string> = {
  '/data-service/annotation': 'annotation:view',
  '/data-service/annotation/create': 'annotation:create',
  '/model-repository': 'model:view',
  '/model-repository/train': 'model:train',
};
```

**后端 API 权限**：
```typescript
// api/dataset/route.ts
export async function POST(req: Request) {
  const user = await getCurrentUser(req);
  
  // 检查权限
  if (!user.permissions.includes('dataset:create')) {
    return new Response('Forbidden', { status: 403 });
  }
  
  // 业务逻辑
  const data = await req.json();
  const dataset = await createDataset({
    ...data,
    tenantId: user.tenantId, // 自动注入租户 ID
    createdBy: user.id,
  });
  
  return Response.json(dataset);
}
```

#### 多租户资源隔离

**数据库层**：
```sql
-- 所有资源表包含 tenant_id
CREATE TABLE datasets (
  id UUID PRIMARY KEY,
  name VARCHAR(255),
  tenant_id UUID NOT NULL,
  created_by UUID,
  created_at TIMESTAMP,
  CONSTRAINT fk_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id)
);

-- 创建索引加速查询
CREATE INDEX idx_datasets_tenant ON datasets(tenant_id);

-- Row-Level Security（PostgreSQL）
CREATE POLICY tenant_isolation ON datasets
USING (tenant_id = current_setting('app.tenant_id')::uuid);
```

**API 层自动注入**：
```typescript
// service/base.ts
class BaseService {
  private getTenantId(): string {
    const user = useAuthStore.getState().user;
    return user?.tenantId || '';
  }
  
  async request<T>(config: RequestConfig): Promise<T> {
    const tenantId = this.getTenantId();
    
    return axios.request({
      ...config,
      headers: {
        ...config.headers,
        'X-Tenant-Id': tenantId,
      },
    });
  }
}
```

#### 70+ 权限设计

**权限分类**（15 个模块）：

| 模块 | 权限数 | 示例权限 |
|------|--------|---------|
| 数据集管理 | 8 | `dataset:create`, `dataset:delete`, `dataset:export`, `dataset:import` |
| 标注管理 | 6 | `annotation:create`, `annotation:review`, `annotation:export` |
| 模型管理 | 5 | `model:view`, `model:train`, `model:deploy`, `model:delete` |
| 模型仓库 | 4 | `repository:view`, `repository:create` |
| 应用管理 | 4 | `app:create`, `app:publish`, `app:delete` |
| API Key | 3 | `apikey:create`, `apikey:delete` |
| 算力资源 | 5 | `resource:view`, `resource:allocate` |
| 租户管理 | 6 | `tenant:create`, `tenant:config` |
| 组织管理 | 4 | `org:view`, `org:edit` |
| 用户管理 | 5 | `user:create`, `user:delete`, `user:assign-role` |
| 角色管理 | 4 | `role:create`, `role:edit`, `role:delete` |
| 权限管理 | 3 | `permission:view`, `permission:assign` |
| MCP 工具 | 6 | `mcp:view`, `mcp:create`, `mcp:deploy` |
| 服务运行 | 4 | `service:view`, `service:start`, `service:stop` |
| 许可证 | 3 | `license:view`, `license:upload` |

**权限命名规范**：
```
{module}:{action}:{resource?}

示例：
- dataset:create           // 创建数据集
- annotation:review        // 审核标注
- model:train:custom       // 训练自定义模型
- user:assign-role         // 分配角色
```

---

### 1.2 AI 标注工具（Fabric.js）

#### 性能优化详解

**问题诊断**：
```typescript
// 性能监控
class PerformanceMonitor {
  measure(name: string, fn: Function) {
    const start = performance.now();
    fn();
    const end = performance.now();
    console.log(`[Performance] ${name}: ${(end - start).toFixed(2)}ms`);
  }
}

const monitor = new PerformanceMonitor();

// 测量渲染时间
monitor.measure('Canvas Render', () => {
  canvas.renderAll(); // 发现耗时 120ms
});

// 测量事件处理
canvas.on('object:modified', (e) => {
  monitor.measure('Save Annotation', () => {
    saveAnnotation(e.target); // 耗时 60ms
  });
});
```

**优化 1：按需渲染**

```typescript
class OptimizedCanvas {
  private canvas: fabric.Canvas;
  private dirtyObjects = new Set<fabric.Object>();
  private renderScheduled = false;
  
  constructor(canvas: fabric.Canvas) {
    this.canvas = canvas;
    this.canvas.renderOnAddRemove = false; // 关闭自动渲染
  }
  
  // 标记对象为脏
  markDirty(obj: fabric.Object) {
    this.dirtyObjects.add(obj);
    this.scheduleRender();
  }
  
  // 调度渲染
  private scheduleRender() {
    if (this.renderScheduled) return;
    
    this.renderScheduled = true;
    requestAnimationFrame(() => {
      this.render();
      this.renderScheduled = false;
    });
  }
  
  // 渲染
  private render() {
    if (this.dirtyObjects.size === 0) return;
    
    // 批量更新
    this.canvas.renderAll();
    this.dirtyObjects.clear();
  }
}

// 使用
const optimizedCanvas = new OptimizedCanvas(canvas);

canvas.on('object:moving', (e) => {
  optimizedCanvas.markDirty(e.target!);
});
```

**优化 2：事件防抖**

```typescript
class AnnotationEventManager {
  private canvas: fabric.Canvas;
  private saveTimer: NodeJS.Timeout | null = null;
  private pendingSaves = new Map<string, fabric.Object>();
  
  constructor(canvas: fabric.Canvas) {
    this.canvas = canvas;
    this.initEvents();
  }
  
  private initEvents() {
    // 操作防抖
    this.canvas.on('object:modified', (e) => {
      if (e.target) {
        this.debounceSave(e.target);
      }
    });
    
    // 选择变化
    this.canvas.on('selection:updated', (e) => {
      this.handleSelectionChange(e);
    });
  }
  
  private debounceSave(target: fabric.Object) {
    const id = target.get('id') as string;
    this.pendingSaves.set(id, target);
    
    if (this.saveTimer) clearTimeout(this.saveTimer);
    
    this.saveTimer = setTimeout(() => {
      this.batchSave();
    }, 300); // 300ms 防抖
  }
  
  private async batchSave() {
    const objects = Array.from(this.pendingSaves.values());
    this.pendingSaves.clear();
    
    // 批量保存
    await saveAnnotations(objects.map(obj => this.serialize(obj)));
  }
  
  private serialize(obj: fabric.Object) {
    return {
      id: obj.get('id'),
      type: obj.type,
      left: obj.left,
      top: obj.top,
      width: obj.width,
      height: obj.height,
      angle: obj.angle,
      scaleX: obj.scaleX,
      scaleY: obj.scaleY,
    };
  }
}
```

**优化 3：对象池**

```typescript
class FabricObjectPool {
  private pool = new Map<string, fabric.Object[]>();
  
  // 获取对象
  acquire(type: string, options?: any): fabric.Object {
    const objects = this.pool.get(type) || [];
    
    if (objects.length > 0) {
      const obj = objects.pop()!;
      obj.set({ visible: true, ...options });
      return obj;
    }
    
    return this.create(type, options);
  }
  
  // 释放对象
  release(obj: fabric.Object) {
    const type = obj.type!;
    obj.set({ visible: false });
    
    const objects = this.pool.get(type) || [];
    objects.push(obj);
    this.pool.set(type, objects);
  }
  
  // 创建对象
  private create(type: string, options?: any): fabric.Object {
    switch (type) {
      case 'rect':
        return new fabric.Rect({
          fill: 'transparent',
          stroke: '#00ff00',
          strokeWidth: 2,
          ...options,
        });
      case 'circle':
        return new fabric.Circle({
          fill: 'transparent',
          stroke: '#00ff00',
          strokeWidth: 2,
          ...options,
        });
      case 'polygon':
        return new fabric.Polygon([], {
          fill: 'rgba(0,255,0,0.3)',
          stroke: '#00ff00',
          strokeWidth: 2,
          ...options,
        });
      default:
        throw new Error(`Unknown type: ${type}`);
    }
  }
  
  // 预创建对象
  prewarm(type: string, count: number) {
    const objects = [];
    for (let i = 0; i < count; i++) {
      objects.push(this.create(type));
    }
    this.pool.set(type, objects);
  }
}

// 使用
const objectPool = new FabricObjectPool();

// 预创建 20 个矩形
objectPool.prewarm('rect', 20);

// 使用时获取
const rect = objectPool.acquire('rect', { left: 100, top: 100 });
canvas.add(rect);

// 删除时释放
canvas.on('object:removed', (e) => {
  if (e.target) {
    objectPool.release(e.target);
  }
});
```

**优化效果对比**：

| 指标 | 优化前 | 优化后 | 提升 |
|------|--------|--------|------|
| 响应时间 | 180ms | 70ms | 61% |
| FPS | 30 | 55+ | 83% |
| 内存占用 | 200MB | 150MB | 25% |
| 长时间标注 | 卡顿 | 流畅 | ✅ |

---

### 1.3 智能标注工具集成

#### 解耦架构设计

```typescript
// 智能标注工具接口
interface ISmartAnnotationTool {
  name: string;
  type: 'segmentation' | 'detection' | 'tracking';
  annotate(image: ImageData, options?: any): Promise<Annotation[]>;
}

// 工具管理器
class SmartAnnotationManager {
  private tools = new Map<string, ISmartAnnotationTool>();
  private eventBus: EventBus;
  
  constructor(eventBus: EventBus) {
    this.eventBus = eventBus;
  }
  
  // 注册工具
  register(tool: ISmartAnnotationTool) {
    this.tools.set(tool.name, tool);
    console.log(`[SmartAnnotation] Registered tool: ${tool.name}`);
  }
  
  // 执行标注
  async execute(toolName: string, image: ImageData, options?: any) {
    const tool = this.tools.get(toolName);
    if (!tool) {
      throw new Error(`Tool ${toolName} not found`);
    }
    
    try {
      // 显示加载
      this.eventBus.emit('annotation:loading', { tool: toolName });
      
      // 调用工具
      const annotations = await tool.annotate(image, options);
      
      // 发布事件
      this.eventBus.emit('annotation:created', {
        source: toolName,
        annotations,
      });
      
      return annotations;
    } catch (error) {
      this.eventBus.emit('annotation:error', {
        tool: toolName,
        error,
      });
      throw error;
    } finally {
      this.eventBus.emit('annotation:loading-end', { tool: toolName });
    }
  }
  
  // 获取所有工具
  getAllTools(): ISmartAnnotationTool[] {
    return Array.from(this.tools.values());
  }
}
```

#### SAM 工具实现

```typescript
class SAMTool implements ISmartAnnotationTool {
  name = 'SAM';
  type = 'segmentation' as const;
  
  async annotate(image: ImageData, options: { points: Point[] }) {
    const { points } = options;
    
    // 调用 SAM API
    const response = await fetch('/api/sam/segment', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        image: await this.imageToBase64(image),
        points,
      }),
    });
    
    if (!response.ok) {
      throw new Error('SAM segmentation failed');
    }
    
    const { masks } = await response.json();
    
    // 转换为标注格式
    return masks.map(mask => this.maskToAnnotation(mask));
  }
  
  private async imageToBase64(image: ImageData): Promise<string> {
    const canvas = document.createElement('canvas');
    canvas.width = image.width;
    canvas.height = image.height;
    const ctx = canvas.getContext('2d')!;
    ctx.putImageData(image, 0, 0);
    return canvas.toDataURL('image/png');
  }
  
  private maskToAnnotation(mask: number[][]): Annotation {
    // 将像素掩码转换为多边形轮廓
    const contours = this.findContours(mask);
    
    return {
      id: generateId(),
      type: 'polygon',
      points: contours,
      label: 'auto-detected',
      confidence: mask.confidence || 0.95,
    };
  }
  
  private findContours(mask: number[][]): Point[] {
    // 使用 marching squares 算法找轮廓
    // 简化实现
    const points: Point[] = [];
    // ... 算法实现
    return points;
  }
}
```

#### YOLO 工具实现

```typescript
class YOLOTool implements ISmartAnnotationTool {
  name = 'YOLO';
  type = 'detection' as const;
  
  async annotate(image: ImageData) {
    const response = await fetch('/api/yolo/detect', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        image: await this.imageToBase64(image),
      }),
    });
    
    if (!response.ok) {
      throw new Error('YOLO detection failed');
    }
    
    const { detections } = await response.json();
    
    return detections.map(det => ({
      id: generateId(),
      type: 'rect',
      left: det.bbox[0],
      top: det.bbox[1],
      width: det.bbox[2],
      height: det.bbox[3],
      label: det.class,
      confidence: det.score,
    }));
  }
  
  private async imageToBase64(image: ImageData): Promise<string> {
    // 同 SAM
  }
}
```

#### 事件解耦使用

```typescript
// 初始化
const eventBus = new EventBus();
const smartAnnotation = new SmartAnnotationManager(eventBus);

// 注册工具
smartAnnotation.register(new SAMTool());
smartAnnotation.register(new YOLOTool());
smartAnnotation.register(new CustomTool());

// 画布监听事件
eventBus.on('annotation:created', ({ annotations }) => {
  annotations.forEach(annotation => {
    const fabricObject = createFabricObject(annotation);
    canvas.add(fabricObject);
  });
  canvas.renderAll();
});

// 数据管理监听事件
eventBus.on('annotation:created', async ({ annotations }) => {
  await saveAnnotations(annotations);
  showToast('标注已保存');
});

// UI 监听加载状态
eventBus.on('annotation:loading', ({ tool }) => {
  showLoading(`${tool} 处理中...`);
});

eventBus.on('annotation:loading-end', () => {
  hideLoading();
});

// 使用工具
async function handleSAMClick(points: Point[]) {
  const imageData = canvas.getContext().getImageData(0, 0, width, height);
  await smartAnnotation.execute('SAM', imageData, { points });
}
```

---

### 1.4 视频标注与追踪

#### 帧管理与预加载

```typescript
class VideoFrameManager {
  private frameCache = new Map<number, ImageBitmap>();
  private preloadQueue: number[] = [];
  private readonly CACHE_SIZE = 50;
  private readonly PRELOAD_RANGE = 10;
  private isPreloading = false;
  
  constructor(private videoUrl: string) {}
  
  // 加载帧
  async loadFrame(frameIndex: number): Promise<ImageBitmap> {
    // 检查缓存
    if (this.frameCache.has(frameIndex)) {
      return this.frameCache.get(frameIndex)!;
    }
    
    // 加载帧
    const frame = await this.fetchFrame(frameIndex);
    this.cacheFrame(frameIndex, frame);
    
    // 触发预加载
    this.schedulePreload(frameIndex);
    
    return frame;
  }
  
  // 获取帧
  private async fetchFrame(frameIndex: number): Promise<ImageBitmap> {
    const response = await fetch(`/api/video/frame?url=${this.videoUrl}&index=${frameIndex}`);
    const blob = await response.blob();
    return createImageBitmap(blob);
  }
  
  // 缓存帧
  private cacheFrame(index: number, frame: ImageBitmap) {
    // LRU 策略
    if (this.frameCache.size >= this.CACHE_SIZE) {
      const firstKey = this.frameCache.keys().next().value;
      const oldFrame = this.frameCache.get(firstKey)!;
      oldFrame.close(); // 释放内存
      this.frameCache.delete(firstKey);
    }
    
    this.frameCache.set(index, frame);
  }
  
  // 调度预加载
  private schedulePreload(currentFrame: number) {
    // 预加载后续帧
    for (let i = 1; i <= this.PRELOAD_RANGE; i++) {
      const nextFrame = currentFrame + i;
      if (!this.frameCache.has(nextFrame) && !this.preloadQueue.includes(nextFrame)) {
        this.preloadQueue.push(nextFrame);
      }
    }
    
    this.processPreloadQueue();
  }
  
  // 处理预加载队列
  private async processPreloadQueue() {
    if (this.isPreloading || this.preloadQueue.length === 0) return;
    
    this.isPreloading = true;
    
    while (this.preloadQueue.length > 0) {
      const frameIndex = this.preloadQueue.shift()!;
      
      try {
        const frame = await this.fetchFrame(frameIndex);
        this.cacheFrame(frameIndex, frame);
      } catch (error) {
        console.error(`Preload frame ${frameIndex} failed:`, error);
      }
      
      // 使用 requestIdleCallback 避免阻塞主线程
      await new Promise(resolve => {
        if ('requestIdleCallback' in window) {
          requestIdleCallback(resolve);
        } else {
          setTimeout(resolve, 16);
        }
      });
    }
    
    this.isPreloading = false;
  }
  
  // 清理缓存
  clear() {
    this.frameCache.forEach(frame => frame.close());
    this.frameCache.clear();
    this.preloadQueue = [];
  }
}
```

#### 视频追踪实现

```typescript
class VideoTracker {
  private tracks = new Map<string, Track>();
  
  constructor(
    private frameManager: VideoFrameManager,
    private canvas: fabric.Canvas
  ) {}
  
  // 追踪对象
  async trackObject(
    startFrame: number,
    endFrame: number,
    initialBox: BoundingBox
  ): Promise<Track> {
    const track: Track = {
      id: generateId(),
      frames: new Map(),
      status: 'tracking',
    };
    
    // 设置起始帧
    track.frames.set(startFrame, initialBox);
    this.renderBox(startFrame, initialBox);
    
    // 逐帧追踪
    for (let i = startFrame + 1; i <= endFrame; i++) {
      try {
        const prevBox = track.frames.get(i - 1)!;
        const currentFrame = await this.frameManager.loadFrame(i);
        
        // 调用追踪 API
        const newBox = await this.track(currentFrame, prevBox);
        track.frames.set(i, newBox);
        
        // 实时渲染
        this.renderBox(i, newBox);
        
        // 更新进度
        const progress = ((i - startFrame) / (endFrame - startFrame)) * 100;
        this.updateProgress(progress);
      } catch (error) {
        console.error(`Tracking failed at frame ${i}:`, error);
        track.status = 'error';
        break;
      }
    }
    
    track.status = 'completed';
    this.tracks.set(track.id, track);
    return track;
  }
  
  // 调用追踪 API
  private async track(
    frame: ImageBitmap,
    prevBox: BoundingBox
  ): Promise<BoundingBox> {
    // 将 ImageBitmap 转换为 Blob
    const canvas = document.createElement('canvas');
    canvas.width = frame.width;
    canvas.height = frame.height;
    const ctx = canvas.getContext('2d')!;
    ctx.drawImage(frame, 0, 0);
    
    const blob = await new Promise<Blob>((resolve) => {
      canvas.toBlob((blob) => resolve(blob!), 'image/jpeg', 0.9);
    });
    
    // 调用 API
    const formData = new FormData();
    formData.append('frame', blob);
    formData.append('box', JSON.stringify(prevBox));
    
    const response = await fetch('/api/tracking', {
      method: 'POST',
      body: formData,
    });
    
    if (!response.ok) {
      throw new Error('Tracking failed');
    }
    
    return response.json();
  }
  
  // 渲染标注框
  private renderBox(frameIndex: number, box: BoundingBox) {
    // 清除当前帧的标注
    this.canvas.getObjects().forEach(obj => {
      if (obj.get('frameIndex') === frameIndex) {
        this.canvas.remove(obj);
      }
    });
    
    // 添加新标注
    const rect = new fabric.Rect({
      left: box.x,
      top: box.y,
      width: box.width,
      height: box.height,
      fill: 'transparent',
      stroke: '#00ff00',
      strokeWidth: 2,
      frameIndex,
    });
    
    this.canvas.add(rect);
    this.canvas.renderAll();
  }
  
  // 更新进度
  private updateProgress(progress: number) {
    // 发布事件
    eventBus.emit('tracking:progress', { progress });
  }
}
```

---

### 1.5 数据管理（React Query）

#### 列表管理

```typescript
// hooks/use-dataset-list.ts
export function useDatasetList(params: DatasetListParams) {
  return useQuery({
    queryKey: ['datasets', params],
    queryFn: () => datasetService.getList(params),
    staleTime: 5 * 60 * 1000, // 5 分钟
    cacheTime: 10 * 60 * 1000, // 10 分钟
    refetchOnWindowFocus: true,
    keepPreviousData: true, // 分页切换时保留旧数据
  });
}

// 使用
function DatasetList() {
  const [page, setPage] = useState(1);
  const [search, setSearch] = useState('');
  
  const { data, isLoading, error } = useDatasetList({
    page,
    pageSize: 20,
    search,
  });
  
  if (isLoading && !data) return <Skeleton count={5} />;
  if (error) return <Error message={error.message} />;
  
  return (
    <div>
      <SearchBox value={search} onChange={setSearch} />
      <Table data={data.items} />
      <Pagination
        current={page}
        total={data.total}
        onChange={setPage}
      />
    </div>
  );
}
```

#### 乐观更新

```typescript
export function useDeleteDataset() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (id: string) => datasetService.delete(id),
    
    onMutate: async (id) => {
      // 取消进行中的查询
      await queryClient.cancelQueries({ queryKey: ['datasets'] });
      
      // 保存旧数据
      const previous = queryClient.getQueryData(['datasets']);
      
      // 乐观更新
      queryClient.setQueryData(['datasets'], (old: any) => ({
        ...old,
        items: old.items.filter((item: any) => item.id !== id),
        total: old.total - 1,
      }));
      
      return { previous };
    },
    
    onError: (err, id, context) => {
      // 回滚
      queryClient.setQueryData(['datasets'], context?.previous);
      toast.error('删除失败：' + err.message);
    },
    
    onSuccess: () => {
      toast.success('删除成功');
    },
    
    onSettled: () => {
      // 重新验证
      queryClient.invalidateQueries({ queryKey: ['datasets'] });
    },
  });
}
```

#### 无限滚动

```typescript
export function useInfiniteDatasets(search?: string) {
  return useInfiniteQuery({
    queryKey: ['datasets-infinite', search],
    queryFn: ({ pageParam = 1 }) =>
      datasetService.getList({
        page: pageParam,
        pageSize: 20,
        search,
      }),
    getNextPageParam: (lastPage, pages) => {
      if (lastPage.items.length < 20) return undefined;
      return pages.length + 1;
    },
  });
}

// 使用
function InfiniteDatasetList() {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useInfiniteDatasets();
  
  const observerRef = useRef<IntersectionObserver>();
  const lastElementRef = useCallback(
    (node: HTMLDivElement | null) => {
      if (isFetchingNextPage) return;
      if (observerRef.current) observerRef.current.disconnect();
      
      observerRef.current = new IntersectionObserver((entries) => {
        if (entries[0].isIntersecting && hasNextPage) {
          fetchNextPage();
        }
      });
      
      if (node) observerRef.current.observe(node);
    },
    [isFetchingNextPage, hasNextPage, fetchNextPage]
  );
  
  return (
    <div>
      {data?.pages.map((page, i) => (
        <React.Fragment key={i}>
          {page.items.map((item, j) => {
            const isLast =
              i === data.pages.length - 1 && j === page.items.length - 1;
            
            return (
              <DatasetCard
                key={item.id}
                data={item}
                ref={isLast ? lastElementRef : null}
              />
            );
          })}
        </React.Fragment>
      ))}
      {isFetchingNextPage && <Skeleton />}
    </div>
  );
}
```

---

## 2. AgentFactory

### 2.1 微前端架构（Wujie）

#### 主应用配置

```typescript
// 主应用 - app/agent-factory/page.tsx
'use client';
import WujieReact from 'wujie-react';
import { useTheme } from 'next-themes';
import { useTranslation } from 'react-i18next';
import { useAuth } from '@/hooks/use-auth';

export default function AgentFactoryPage() {
  const { theme } = useTheme();
  const { i18n } = useTranslation();
  const { token, user } = useAuth();
  
  return (
    <WujieReact
      name="agentfactory"
      url={process.env.NEXT_PUBLIC_AGENT_FACTORY_URL}
      props={{
        theme,
        language: i18n.language,
        token,
        user,
      }}
      alive={true} // 保活
      fetch={(url, options) => {
        // 自定义请求（处理跨域、认证等）
        return fetch(url, {
          ...options,
          headers: {
            ...options?.headers,
            Authorization: `Bearer ${token}`,
          },
        });
      }}
    />
  );
}
```

#### 子应用集成

```typescript
// 子应用 - src/main.tsx
import { createRoot } from 'react-dom/client';
import App from './App';

// 检测是否在 Wujie 环境
const isWujie = window.__POWERED_BY_WUJIE__;

// 生命周期
if (isWujie) {
  // 微前端模式
  if (window.__WUJIE_MOUNT__) {
    window.__WUJIE_MOUNT__();
  }
  
  if (window.__WUJIE_UNMOUNT__) {
    window.__WUJIE_UNMOUNT__();
  }
} else {
  // 独立模式
  const container = document.getElementById('root');
  const root = createRoot(container!);
  root.render(<App />);
}

// App 组件中处理 props
function App() {
  const [config, setConfig] = useState(getConfig());
  
  useEffect(() => {
    if (window.$wujie) {
      // 监听 props 变化
      const handlePropsChange = () => {
        const props = window.$wujie?.props;
        if (props) {
          // 同步主题
          if (props.theme) {
            document.documentElement.setAttribute('data-theme', props.theme);
          }
          
          // 同步语言
          if (props.language) {
            i18n.changeLanguage(props.language);
          }
          
          // 同步 Token
          if (props.token) {
            authStore.setToken(props.token);
          }
        }
      };
      
      // 初始化
      handlePropsChange();
      
      // 监听变化（轮询检查）
      const interval = setInterval(handlePropsChange, 100);
      
      return () => clearInterval(interval);
    }
  }, []);
  
  return <Router />;
}

function getConfig() {
  if (window.$wujie?.props) {
    return window.$wujie.props;
  }
  
  // 独立运行
  return {
    theme: localStorage.getItem('theme') || 'light',
    language: localStorage.getItem('language') || 'zh',
    token: localStorage.getItem('token'),
  };
}
```

#### 事件通信

```typescript
// 子应用发送事件
window.$wujie?.bus.$emit('agent:route-change', {
  path: '/workflow/edit/123',
  title: '编辑工作流',
});

window.$wujie?.bus.$emit('agent:data-updated', {
  type: 'workflow',
  id: '123',
});

// 主应用监听事件
const bus = WujieReact.bus;

bus.$on('agent:route-change', (data) => {
  // 更新面包屑
  updateBreadcrumbs(data);
});

bus.$on('agent:data-updated', (data) => {
  // 刷新相关数据
  queryClient.invalidateQueries(['workflows']);
});
```

---

### 2.2 性能优化（HTTP 请求减少 90%+）

#### Vite 配置优化

```typescript
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { visualizer } from 'rollup-plugin-visualizer';

export default defineConfig({
  plugins: [
    react(),
    visualizer({ open: true }), // 构建分析
  ],
  
  build: {
    rollupOptions: {
      output: {
        // 手动分包
        manualChunks: (id) => {
          // 第三方库
          if (id.includes('node_modules')) {
            // React 相关
            if (id.includes('react') || id.includes('react-dom')) {
              return 'react-vendor';
            }
            
            // UI 库
            if (id.includes('@mui') || id.includes('@emotion')) {
              return 'mui-vendor';
            }
            
            // ReactFlow
            if (id.includes('reactflow')) {
              return 'reactflow-vendor';
            }
            
            // Redux
            if (id.includes('redux') || id.includes('@reduxjs')) {
              return 'redux-vendor';
            }
            
            // 其他第三方库
            return 'vendor';
          }
          
          // 业务代码按路由分组
          if (id.includes('/src/pages/')) {
            const match = id.match(/\/pages\/([^/]+)/);
            if (match) {
              return `page-${match[1]}`;
            }
          }
          
          // 通用组件
          if (id.includes('/src/components/')) {
            return 'components';
          }
        },
      },
    },
    
    // 代码分割阈值
    chunkSizeWarningLimit: 1000,
    
    // 压缩
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true, // 移除 console
        drop_debugger: true,
      },
    },
  },
  
  // 依赖预构建
  optimizeDeps: {
    include: [
      'react',
      'react-dom',
      '@mui/material',
      'reactflow',
      '@reduxjs/toolkit',
    ],
  },
});
```

#### 路由懒加载

```typescript
// src/App.tsx
import { lazy, Suspense } from '