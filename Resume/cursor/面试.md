# æŠ€æœ¯å®ç°è¯¦è§£ - å®Œæ•´æŠ€æœ¯æ‰‹å†Œ

æœ¬æ–‡æ¡£æ˜¯ã€Šé¢è¯•å‡†å¤‡-æ ¸å¿ƒæŒ‡å—ã€‹çš„æŠ€æœ¯è¡¥å……ï¼ŒåŒ…å«æ‰€æœ‰é¡¹ç›®çš„è¯¦ç»†æŠ€æœ¯å®ç°è¿‡ç¨‹ã€‚

---

## ğŸ“š ç›®å½•

1. [AI æ™ºèƒ½å¼€å‘å¹³å° - æŠ€æœ¯å®ç°](#1-ai-æ™ºèƒ½å¼€å‘å¹³å°)
2. [AgentFactory - æŠ€æœ¯å®ç°](#2-agentfactory)
3. [æ²³åŒ—é“¶è¡Œç³»ç»Ÿ - æŠ€æœ¯å®ç°](#3-æ²³åŒ—é“¶è¡Œç³»ç»Ÿ)
4. [å‹åˆ©é“¶è¡Œç³»ç»Ÿ - æŠ€æœ¯å®ç°](#4-å‹åˆ©é“¶è¡Œç³»ç»Ÿ)
5. [æŠ€æœ¯æ·±åº¦é—®ç­”](#5-æŠ€æœ¯æ·±åº¦é—®ç­”)

---

## 1. AI æ™ºèƒ½å¼€å‘å¹³å°

### 1.1 RBAC æƒé™ç³»ç»Ÿï¼ˆ70+ æƒé™ï¼‰

#### æŠ€æœ¯æ¶æ„

```typescript
// æƒé™æ•°æ®æ¨¡å‹
interface Permission {
  id: string;
  code: string;              // å¦‚ 'dataset:create'
  name: string;
  module: string;            // æ‰€å±æ¨¡å—
  resource: string;          // èµ„æºç±»å‹
  action: string;            // æ“ä½œç±»å‹
}

interface Role {
  id: string;
  name: string;
  tenantId: string;          // å¤šç§Ÿæˆ·éš”ç¦»
  permissions: Permission[];
  isSystem: boolean;         // ç³»ç»Ÿé¢„è®¾è§’è‰²
}

interface UserRoleBinding {
  userId: string;
  roleIds: string[];
  tenantId: string;
}
```

#### æƒé™æ£€æŸ¥æœºåˆ¶

**å‰ç«¯æƒé™æ£€æŸ¥**ï¼š
```typescript
// hooks/use-permission.ts
export function usePermission() {
  const { user } = useAuth();
  
  const hasPermission = useCallback((permissionCode: string) => {
    if (!user?.permissions) return false;
    return user.permissions.some(p => p.code === permissionCode);
  }, [user]);
  
  const hasAnyPermission = useCallback((codes: string[]) => {
    return codes.some(code => hasPermission(code));
  }, [hasPermission]);
  
  const hasAllPermissions = useCallback((codes: string[]) => {
    return codes.every(code => hasPermission(code));
  }, [hasPermission]);
  
  return { hasPermission, hasAnyPermission, hasAllPermissions };
}

// ç»„ä»¶ä¸­ä½¿ç”¨
function DatasetActions() {
  const { hasPermission } = usePermission();
  
  return (
    <div className="actions">
      {hasPermission('dataset:create') && (
        <Button onClick={handleCreate}>åˆ›å»ºæ•°æ®é›†</Button>
      )}
      {hasPermission('dataset:delete') && (
        <Button onClick={handleDelete} variant="danger">åˆ é™¤</Button>
      )}
    </div>
  );
}
```

**è·¯ç”±çº§æƒé™**ï¼š
```typescript
// middleware.ts
export async function middleware(request: NextRequest) {
  const token = request.cookies.get('token')?.value;
  
  // éªŒè¯ token
  const user = await verifyToken(token);
  if (!user) {
    return NextResponse.redirect(new URL('/login', request.url));
  }
  
  // æ£€æŸ¥è·¯ç”±æƒé™
  const pathname = request.nextUrl.pathname;
  const requiredPermission = getRoutePermission(pathname);
  
  if (requiredPermission && !user.permissions.includes(requiredPermission)) {
    return new Response('Forbidden', { status: 403 });
  }
  
  return NextResponse.next();
}

// è·¯ç”±æƒé™é…ç½®
const routePermissions: Record<string, string> = {
  '/data-service/annotation': 'annotation:view',
  '/data-service/annotation/create': 'annotation:create',
  '/model-repository': 'model:view',
  '/model-repository/train': 'model:train',
};
```

**åç«¯ API æƒé™**ï¼š
```typescript
// api/dataset/route.ts
export async function POST(req: Request) {
  const user = await getCurrentUser(req);
  
  // æ£€æŸ¥æƒé™
  if (!user.permissions.includes('dataset:create')) {
    return new Response('Forbidden', { status: 403 });
  }
  
  // ä¸šåŠ¡é€»è¾‘
  const data = await req.json();
  const dataset = await createDataset({
    ...data,
    tenantId: user.tenantId, // è‡ªåŠ¨æ³¨å…¥ç§Ÿæˆ· ID
    createdBy: user.id,
  });
  
  return Response.json(dataset);
}
```

#### å¤šç§Ÿæˆ·èµ„æºéš”ç¦»

**æ•°æ®åº“å±‚**ï¼š
```sql
-- æ‰€æœ‰èµ„æºè¡¨åŒ…å« tenant_id
CREATE TABLE datasets (
  id UUID PRIMARY KEY,
  name VARCHAR(255),
  tenant_id UUID NOT NULL,
  created_by UUID,
  created_at TIMESTAMP,
  CONSTRAINT fk_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id)
);

-- åˆ›å»ºç´¢å¼•åŠ é€ŸæŸ¥è¯¢
CREATE INDEX idx_datasets_tenant ON datasets(tenant_id);

-- Row-Level Securityï¼ˆPostgreSQLï¼‰
CREATE POLICY tenant_isolation ON datasets
USING (tenant_id = current_setting('app.tenant_id')::uuid);
```

**API å±‚è‡ªåŠ¨æ³¨å…¥**ï¼š
```typescript
// service/base.ts
class BaseService {
  private getTenantId(): string {
    const user = useAuthStore.getState().user;
    return user?.tenantId || '';
  }
  
  async request<T>(config: RequestConfig): Promise<T> {
    const tenantId = this.getTenantId();
    
    return axios.request({
      ...config,
      headers: {
        ...config.headers,
        'X-Tenant-Id': tenantId,
      },
    });
  }
}
```

#### 70+ æƒé™è®¾è®¡

**æƒé™åˆ†ç±»**ï¼ˆ15 ä¸ªæ¨¡å—ï¼‰ï¼š

| æ¨¡å— | æƒé™æ•° | ç¤ºä¾‹æƒé™ |
|------|--------|---------|
| æ•°æ®é›†ç®¡ç† | 8 | `dataset:create`, `dataset:delete`, `dataset:export`, `dataset:import` |
| æ ‡æ³¨ç®¡ç† | 6 | `annotation:create`, `annotation:review`, `annotation:export` |
| æ¨¡å‹ç®¡ç† | 5 | `model:view`, `model:train`, `model:deploy`, `model:delete` |
| æ¨¡å‹ä»“åº“ | 4 | `repository:view`, `repository:create` |
| åº”ç”¨ç®¡ç† | 4 | `app:create`, `app:publish`, `app:delete` |
| API Key | 3 | `apikey:create`, `apikey:delete` |
| ç®—åŠ›èµ„æº | 5 | `resource:view`, `resource:allocate` |
| ç§Ÿæˆ·ç®¡ç† | 6 | `tenant:create`, `tenant:config` |
| ç»„ç»‡ç®¡ç† | 4 | `org:view`, `org:edit` |
| ç”¨æˆ·ç®¡ç† | 5 | `user:create`, `user:delete`, `user:assign-role` |
| è§’è‰²ç®¡ç† | 4 | `role:create`, `role:edit`, `role:delete` |
| æƒé™ç®¡ç† | 3 | `permission:view`, `permission:assign` |
| MCP å·¥å…· | 6 | `mcp:view`, `mcp:create`, `mcp:deploy` |
| æœåŠ¡è¿è¡Œ | 4 | `service:view`, `service:start`, `service:stop` |
| è®¸å¯è¯ | 3 | `license:view`, `license:upload` |

**æƒé™å‘½åè§„èŒƒ**ï¼š
```
{module}:{action}:{resource?}

ç¤ºä¾‹ï¼š
- dataset:create           // åˆ›å»ºæ•°æ®é›†
- annotation:review        // å®¡æ ¸æ ‡æ³¨
- model:train:custom       // è®­ç»ƒè‡ªå®šä¹‰æ¨¡å‹
- user:assign-role         // åˆ†é…è§’è‰²
```

---

### 1.2 AI æ ‡æ³¨å·¥å…·ï¼ˆFabric.jsï¼‰

#### æ€§èƒ½ä¼˜åŒ–è¯¦è§£

**é—®é¢˜è¯Šæ–­**ï¼š
```typescript
// æ€§èƒ½ç›‘æ§
class PerformanceMonitor {
  measure(name: string, fn: Function) {
    const start = performance.now();
    fn();
    const end = performance.now();
    console.log(`[Performance] ${name}: ${(end - start).toFixed(2)}ms`);
  }
}

const monitor = new PerformanceMonitor();

// æµ‹é‡æ¸²æŸ“æ—¶é—´
monitor.measure('Canvas Render', () => {
  canvas.renderAll(); // å‘ç°è€—æ—¶ 120ms
});

// æµ‹é‡äº‹ä»¶å¤„ç†
canvas.on('object:modified', (e) => {
  monitor.measure('Save Annotation', () => {
    saveAnnotation(e.target); // è€—æ—¶ 60ms
  });
});
```

**ä¼˜åŒ– 1ï¼šæŒ‰éœ€æ¸²æŸ“**

```typescript
class OptimizedCanvas {
  private canvas: fabric.Canvas;
  private dirtyObjects = new Set<fabric.Object>();
  private renderScheduled = false;
  
  constructor(canvas: fabric.Canvas) {
    this.canvas = canvas;
    this.canvas.renderOnAddRemove = false; // å…³é—­è‡ªåŠ¨æ¸²æŸ“
  }
  
  // æ ‡è®°å¯¹è±¡ä¸ºè„
  markDirty(obj: fabric.Object) {
    this.dirtyObjects.add(obj);
    this.scheduleRender();
  }
  
  // è°ƒåº¦æ¸²æŸ“
  private scheduleRender() {
    if (this.renderScheduled) return;
    
    this.renderScheduled = true;
    requestAnimationFrame(() => {
      this.render();
      this.renderScheduled = false;
    });
  }
  
  // æ¸²æŸ“
  private render() {
    if (this.dirtyObjects.size === 0) return;
    
    // æ‰¹é‡æ›´æ–°
    this.canvas.renderAll();
    this.dirtyObjects.clear();
  }
}

// ä½¿ç”¨
const optimizedCanvas = new OptimizedCanvas(canvas);

canvas.on('object:moving', (e) => {
  optimizedCanvas.markDirty(e.target!);
});
```

**ä¼˜åŒ– 2ï¼šäº‹ä»¶é˜²æŠ–**

```typescript
class AnnotationEventManager {
  private canvas: fabric.Canvas;
  private saveTimer: NodeJS.Timeout | null = null;
  private pendingSaves = new Map<string, fabric.Object>();
  
  constructor(canvas: fabric.Canvas) {
    this.canvas = canvas;
    this.initEvents();
  }
  
  private initEvents() {
    // æ“ä½œé˜²æŠ–
    this.canvas.on('object:modified', (e) => {
      if (e.target) {
        this.debounceSave(e.target);
      }
    });
    
    // é€‰æ‹©å˜åŒ–
    this.canvas.on('selection:updated', (e) => {
      this.handleSelectionChange(e);
    });
  }
  
  private debounceSave(target: fabric.Object) {
    const id = target.get('id') as string;
    this.pendingSaves.set(id, target);
    
    if (this.saveTimer) clearTimeout(this.saveTimer);
    
    this.saveTimer = setTimeout(() => {
      this.batchSave();
    }, 300); // 300ms é˜²æŠ–
  }
  
  private async batchSave() {
    const objects = Array.from(this.pendingSaves.values());
    this.pendingSaves.clear();
    
    // æ‰¹é‡ä¿å­˜
    await saveAnnotations(objects.map(obj => this.serialize(obj)));
  }
  
  private serialize(obj: fabric.Object) {
    return {
      id: obj.get('id'),
      type: obj.type,
      left: obj.left,
      top: obj.top,
      width: obj.width,
      height: obj.height,
      angle: obj.angle,
      scaleX: obj.scaleX,
      scaleY: obj.scaleY,
    };
  }
}
```

**ä¼˜åŒ– 3ï¼šå¯¹è±¡æ± **

```typescript
class FabricObjectPool {
  private pool = new Map<string, fabric.Object[]>();
  
  // è·å–å¯¹è±¡
  acquire(type: string, options?: any): fabric.Object {
    const objects = this.pool.get(type) || [];
    
    if (objects.length > 0) {
      const obj = objects.pop()!;
      obj.set({ visible: true, ...options });
      return obj;
    }
    
    return this.create(type, options);
  }
  
  // é‡Šæ”¾å¯¹è±¡
  release(obj: fabric.Object) {
    const type = obj.type!;
    obj.set({ visible: false });
    
    const objects = this.pool.get(type) || [];
    objects.push(obj);
    this.pool.set(type, objects);
  }
  
  // åˆ›å»ºå¯¹è±¡
  private create(type: string, options?: any): fabric.Object {
    switch (type) {
      case 'rect':
        return new fabric.Rect({
          fill: 'transparent',
          stroke: '#00ff00',
          strokeWidth: 2,
          ...options,
        });
      case 'circle':
        return new fabric.Circle({
          fill: 'transparent',
          stroke: '#00ff00',
          strokeWidth: 2,
          ...options,
        });
      case 'polygon':
        return new fabric.Polygon([], {
          fill: 'rgba(0,255,0,0.3)',
          stroke: '#00ff00',
          strokeWidth: 2,
          ...options,
        });
      default:
        throw new Error(`Unknown type: ${type}`);
    }
  }
  
  // é¢„åˆ›å»ºå¯¹è±¡
  prewarm(type: string, count: number) {
    const objects = [];
    for (let i = 0; i < count; i++) {
      objects.push(this.create(type));
    }
    this.pool.set(type, objects);
  }
}

// ä½¿ç”¨
const objectPool = new FabricObjectPool();

// é¢„åˆ›å»º 20 ä¸ªçŸ©å½¢
objectPool.prewarm('rect', 20);

// ä½¿ç”¨æ—¶è·å–
const rect = objectPool.acquire('rect', { left: 100, top: 100 });
canvas.add(rect);

// åˆ é™¤æ—¶é‡Šæ”¾
canvas.on('object:removed', (e) => {
  if (e.target) {
    objectPool.release(e.target);
  }
});
```

**ä¼˜åŒ–æ•ˆæœå¯¹æ¯”**ï¼š

| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æå‡ |
|------|--------|--------|------|
| å“åº”æ—¶é—´ | 180ms | 70ms | 61% |
| FPS | 30 | 55+ | 83% |
| å†…å­˜å ç”¨ | 200MB | 150MB | 25% |
| é•¿æ—¶é—´æ ‡æ³¨ | å¡é¡¿ | æµç•… | âœ… |

---

### 1.3 æ™ºèƒ½æ ‡æ³¨å·¥å…·é›†æˆ

#### è§£è€¦æ¶æ„è®¾è®¡

```typescript
// æ™ºèƒ½æ ‡æ³¨å·¥å…·æ¥å£
interface ISmartAnnotationTool {
  name: string;
  type: 'segmentation' | 'detection' | 'tracking';
  annotate(image: ImageData, options?: any): Promise<Annotation[]>;
}

// å·¥å…·ç®¡ç†å™¨
class SmartAnnotationManager {
  private tools = new Map<string, ISmartAnnotationTool>();
  private eventBus: EventBus;
  
  constructor(eventBus: EventBus) {
    this.eventBus = eventBus;
  }
  
  // æ³¨å†Œå·¥å…·
  register(tool: ISmartAnnotationTool) {
    this.tools.set(tool.name, tool);
    console.log(`[SmartAnnotation] Registered tool: ${tool.name}`);
  }
  
  // æ‰§è¡Œæ ‡æ³¨
  async execute(toolName: string, image: ImageData, options?: any) {
    const tool = this.tools.get(toolName);
    if (!tool) {
      throw new Error(`Tool ${toolName} not found`);
    }
    
    try {
      // æ˜¾ç¤ºåŠ è½½
      this.eventBus.emit('annotation:loading', { tool: toolName });
      
      // è°ƒç”¨å·¥å…·
      const annotations = await tool.annotate(image, options);
      
      // å‘å¸ƒäº‹ä»¶
      this.eventBus.emit('annotation:created', {
        source: toolName,
        annotations,
      });
      
      return annotations;
    } catch (error) {
      this.eventBus.emit('annotation:error', {
        tool: toolName,
        error,
      });
      throw error;
    } finally {
      this.eventBus.emit('annotation:loading-end', { tool: toolName });
    }
  }
  
  // è·å–æ‰€æœ‰å·¥å…·
  getAllTools(): ISmartAnnotationTool[] {
    return Array.from(this.tools.values());
  }
}
```

#### SAM å·¥å…·å®ç°

```typescript
class SAMTool implements ISmartAnnotationTool {
  name = 'SAM';
  type = 'segmentation' as const;
  
  async annotate(image: ImageData, options: { points: Point[] }) {
    const { points } = options;
    
    // è°ƒç”¨ SAM API
    const response = await fetch('/api/sam/segment', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        image: await this.imageToBase64(image),
        points,
      }),
    });
    
    if (!response.ok) {
      throw new Error('SAM segmentation failed');
    }
    
    const { masks } = await response.json();
    
    // è½¬æ¢ä¸ºæ ‡æ³¨æ ¼å¼
    return masks.map(mask => this.maskToAnnotation(mask));
  }
  
  private async imageToBase64(image: ImageData): Promise<string> {
    const canvas = document.createElement('canvas');
    canvas.width = image.width;
    canvas.height = image.height;
    const ctx = canvas.getContext('2d')!;
    ctx.putImageData(image, 0, 0);
    return canvas.toDataURL('image/png');
  }
  
  private maskToAnnotation(mask: number[][]): Annotation {
    // å°†åƒç´ æ©ç è½¬æ¢ä¸ºå¤šè¾¹å½¢è½®å»“
    const contours = this.findContours(mask);
    
    return {
      id: generateId(),
      type: 'polygon',
      points: contours,
      label: 'auto-detected',
      confidence: mask.confidence || 0.95,
    };
  }
  
  private findContours(mask: number[][]): Point[] {
    // ä½¿ç”¨ marching squares ç®—æ³•æ‰¾è½®å»“
    // ç®€åŒ–å®ç°
    const points: Point[] = [];
    // ... ç®—æ³•å®ç°
    return points;
  }
}
```

#### YOLO å·¥å…·å®ç°

```typescript
class YOLOTool implements ISmartAnnotationTool {
  name = 'YOLO';
  type = 'detection' as const;
  
  async annotate(image: ImageData) {
    const response = await fetch('/api/yolo/detect', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        image: await this.imageToBase64(image),
      }),
    });
    
    if (!response.ok) {
      throw new Error('YOLO detection failed');
    }
    
    const { detections } = await response.json();
    
    return detections.map(det => ({
      id: generateId(),
      type: 'rect',
      left: det.bbox[0],
      top: det.bbox[1],
      width: det.bbox[2],
      height: det.bbox[3],
      label: det.class,
      confidence: det.score,
    }));
  }
  
  private async imageToBase64(image: ImageData): Promise<string> {
    // åŒ SAM
  }
}
```

#### äº‹ä»¶è§£è€¦ä½¿ç”¨

```typescript
// åˆå§‹åŒ–
const eventBus = new EventBus();
const smartAnnotation = new SmartAnnotationManager(eventBus);

// æ³¨å†Œå·¥å…·
smartAnnotation.register(new SAMTool());
smartAnnotation.register(new YOLOTool());
smartAnnotation.register(new CustomTool());

// ç”»å¸ƒç›‘å¬äº‹ä»¶
eventBus.on('annotation:created', ({ annotations }) => {
  annotations.forEach(annotation => {
    const fabricObject = createFabricObject(annotation);
    canvas.add(fabricObject);
  });
  canvas.renderAll();
});

// æ•°æ®ç®¡ç†ç›‘å¬äº‹ä»¶
eventBus.on('annotation:created', async ({ annotations }) => {
  await saveAnnotations(annotations);
  showToast('æ ‡æ³¨å·²ä¿å­˜');
});

// UI ç›‘å¬åŠ è½½çŠ¶æ€
eventBus.on('annotation:loading', ({ tool }) => {
  showLoading(`${tool} å¤„ç†ä¸­...`);
});

eventBus.on('annotation:loading-end', () => {
  hideLoading();
});

// ä½¿ç”¨å·¥å…·
async function handleSAMClick(points: Point[]) {
  const imageData = canvas.getContext().getImageData(0, 0, width, height);
  await smartAnnotation.execute('SAM', imageData, { points });
}
```

---

### 1.4 è§†é¢‘æ ‡æ³¨ä¸è¿½è¸ª

#### å¸§ç®¡ç†ä¸é¢„åŠ è½½

```typescript
class VideoFrameManager {
  private frameCache = new Map<number, ImageBitmap>();
  private preloadQueue: number[] = [];
  private readonly CACHE_SIZE = 50;
  private readonly PRELOAD_RANGE = 10;
  private isPreloading = false;
  
  constructor(private videoUrl: string) {}
  
  // åŠ è½½å¸§
  async loadFrame(frameIndex: number): Promise<ImageBitmap> {
    // æ£€æŸ¥ç¼“å­˜
    if (this.frameCache.has(frameIndex)) {
      return this.frameCache.get(frameIndex)!;
    }
    
    // åŠ è½½å¸§
    const frame = await this.fetchFrame(frameIndex);
    this.cacheFrame(frameIndex, frame);
    
    // è§¦å‘é¢„åŠ è½½
    this.schedulePreload(frameIndex);
    
    return frame;
  }
  
  // è·å–å¸§
  private async fetchFrame(frameIndex: number): Promise<ImageBitmap> {
    const response = await fetch(`/api/video/frame?url=${this.videoUrl}&index=${frameIndex}`);
    const blob = await response.blob();
    return createImageBitmap(blob);
  }
  
  // ç¼“å­˜å¸§
  private cacheFrame(index: number, frame: ImageBitmap) {
    // LRU ç­–ç•¥
    if (this.frameCache.size >= this.CACHE_SIZE) {
      const firstKey = this.frameCache.keys().next().value;
      const oldFrame = this.frameCache.get(firstKey)!;
      oldFrame.close(); // é‡Šæ”¾å†…å­˜
      this.frameCache.delete(firstKey);
    }
    
    this.frameCache.set(index, frame);
  }
  
  // è°ƒåº¦é¢„åŠ è½½
  private schedulePreload(currentFrame: number) {
    // é¢„åŠ è½½åç»­å¸§
    for (let i = 1; i <= this.PRELOAD_RANGE; i++) {
      const nextFrame = currentFrame + i;
      if (!this.frameCache.has(nextFrame) && !this.preloadQueue.includes(nextFrame)) {
        this.preloadQueue.push(nextFrame);
      }
    }
    
    this.processPreloadQueue();
  }
  
  // å¤„ç†é¢„åŠ è½½é˜Ÿåˆ—
  private async processPreloadQueue() {
    if (this.isPreloading || this.preloadQueue.length === 0) return;
    
    this.isPreloading = true;
    
    while (this.preloadQueue.length > 0) {
      const frameIndex = this.preloadQueue.shift()!;
      
      try {
        const frame = await this.fetchFrame(frameIndex);
        this.cacheFrame(frameIndex, frame);
      } catch (error) {
        console.error(`Preload frame ${frameIndex} failed:`, error);
      }
      
      // ä½¿ç”¨ requestIdleCallback é¿å…é˜»å¡ä¸»çº¿ç¨‹
      await new Promise(resolve => {
        if ('requestIdleCallback' in window) {
          requestIdleCallback(resolve);
        } else {
          setTimeout(resolve, 16);
        }
      });
    }
    
    this.isPreloading = false;
  }
  
  // æ¸…ç†ç¼“å­˜
  clear() {
    this.frameCache.forEach(frame => frame.close());
    this.frameCache.clear();
    this.preloadQueue = [];
  }
}
```

#### è§†é¢‘è¿½è¸ªå®ç°

```typescript
class VideoTracker {
  private tracks = new Map<string, Track>();
  
  constructor(
    private frameManager: VideoFrameManager,
    private canvas: fabric.Canvas
  ) {}
  
  // è¿½è¸ªå¯¹è±¡
  async trackObject(
    startFrame: number,
    endFrame: number,
    initialBox: BoundingBox
  ): Promise<Track> {
    const track: Track = {
      id: generateId(),
      frames: new Map(),
      status: 'tracking',
    };
    
    // è®¾ç½®èµ·å§‹å¸§
    track.frames.set(startFrame, initialBox);
    this.renderBox(startFrame, initialBox);
    
    // é€å¸§è¿½è¸ª
    for (let i = startFrame + 1; i <= endFrame; i++) {
      try {
        const prevBox = track.frames.get(i - 1)!;
        const currentFrame = await this.frameManager.loadFrame(i);
        
        // è°ƒç”¨è¿½è¸ª API
        const newBox = await this.track(currentFrame, prevBox);
        track.frames.set(i, newBox);
        
        // å®æ—¶æ¸²æŸ“
        this.renderBox(i, newBox);
        
        // æ›´æ–°è¿›åº¦
        const progress = ((i - startFrame) / (endFrame - startFrame)) * 100;
        this.updateProgress(progress);
      } catch (error) {
        console.error(`Tracking failed at frame ${i}:`, error);
        track.status = 'error';
        break;
      }
    }
    
    track.status = 'completed';
    this.tracks.set(track.id, track);
    return track;
  }
  
  // è°ƒç”¨è¿½è¸ª API
  private async track(
    frame: ImageBitmap,
    prevBox: BoundingBox
  ): Promise<BoundingBox> {
    // å°† ImageBitmap è½¬æ¢ä¸º Blob
    const canvas = document.createElement('canvas');
    canvas.width = frame.width;
    canvas.height = frame.height;
    const ctx = canvas.getContext('2d')!;
    ctx.drawImage(frame, 0, 0);
    
    const blob = await new Promise<Blob>((resolve) => {
      canvas.toBlob((blob) => resolve(blob!), 'image/jpeg', 0.9);
    });
    
    // è°ƒç”¨ API
    const formData = new FormData();
    formData.append('frame', blob);
    formData.append('box', JSON.stringify(prevBox));
    
    const response = await fetch('/api/tracking', {
      method: 'POST',
      body: formData,
    });
    
    if (!response.ok) {
      throw new Error('Tracking failed');
    }
    
    return response.json();
  }
  
  // æ¸²æŸ“æ ‡æ³¨æ¡†
  private renderBox(frameIndex: number, box: BoundingBox) {
    // æ¸…é™¤å½“å‰å¸§çš„æ ‡æ³¨
    this.canvas.getObjects().forEach(obj => {
      if (obj.get('frameIndex') === frameIndex) {
        this.canvas.remove(obj);
      }
    });
    
    // æ·»åŠ æ–°æ ‡æ³¨
    const rect = new fabric.Rect({
      left: box.x,
      top: box.y,
      width: box.width,
      height: box.height,
      fill: 'transparent',
      stroke: '#00ff00',
      strokeWidth: 2,
      frameIndex,
    });
    
    this.canvas.add(rect);
    this.canvas.renderAll();
  }
  
  // æ›´æ–°è¿›åº¦
  private updateProgress(progress: number) {
    // å‘å¸ƒäº‹ä»¶
    eventBus.emit('tracking:progress', { progress });
  }
}
```

---

### 1.5 æ•°æ®ç®¡ç†ï¼ˆReact Queryï¼‰

#### åˆ—è¡¨ç®¡ç†

```typescript
// hooks/use-dataset-list.ts
export function useDatasetList(params: DatasetListParams) {
  return useQuery({
    queryKey: ['datasets', params],
    queryFn: () => datasetService.getList(params),
    staleTime: 5 * 60 * 1000, // 5 åˆ†é’Ÿ
    cacheTime: 10 * 60 * 1000, // 10 åˆ†é’Ÿ
    refetchOnWindowFocus: true,
    keepPreviousData: true, // åˆ†é¡µåˆ‡æ¢æ—¶ä¿ç•™æ—§æ•°æ®
  });
}

// ä½¿ç”¨
function DatasetList() {
  const [page, setPage] = useState(1);
  const [search, setSearch] = useState('');
  
  const { data, isLoading, error } = useDatasetList({
    page,
    pageSize: 20,
    search,
  });
  
  if (isLoading && !data) return <Skeleton count={5} />;
  if (error) return <Error message={error.message} />;
  
  return (
    <div>
      <SearchBox value={search} onChange={setSearch} />
      <Table data={data.items} />
      <Pagination
        current={page}
        total={data.total}
        onChange={setPage}
      />
    </div>
  );
}
```

#### ä¹è§‚æ›´æ–°

```typescript
export function useDeleteDataset() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (id: string) => datasetService.delete(id),
    
    onMutate: async (id) => {
      // å–æ¶ˆè¿›è¡Œä¸­çš„æŸ¥è¯¢
      await queryClient.cancelQueries({ queryKey: ['datasets'] });
      
      // ä¿å­˜æ—§æ•°æ®
      const previous = queryClient.getQueryData(['datasets']);
      
      // ä¹è§‚æ›´æ–°
      queryClient.setQueryData(['datasets'], (old: any) => ({
        ...old,
        items: old.items.filter((item: any) => item.id !== id),
        total: old.total - 1,
      }));
      
      return { previous };
    },
    
    onError: (err, id, context) => {
      // å›æ»š
      queryClient.setQueryData(['datasets'], context?.previous);
      toast.error('åˆ é™¤å¤±è´¥ï¼š' + err.message);
    },
    
    onSuccess: () => {
      toast.success('åˆ é™¤æˆåŠŸ');
    },
    
    onSettled: () => {
      // é‡æ–°éªŒè¯
      queryClient.invalidateQueries({ queryKey: ['datasets'] });
    },
  });
}
```

#### æ— é™æ»šåŠ¨

```typescript
export function useInfiniteDatasets(search?: string) {
  return useInfiniteQuery({
    queryKey: ['datasets-infinite', search],
    queryFn: ({ pageParam = 1 }) =>
      datasetService.getList({
        page: pageParam,
        pageSize: 20,
        search,
      }),
    getNextPageParam: (lastPage, pages) => {
      if (lastPage.items.length < 20) return undefined;
      return pages.length + 1;
    },
  });
}

// ä½¿ç”¨
function InfiniteDatasetList() {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useInfiniteDatasets();
  
  const observerRef = useRef<IntersectionObserver>();
  const lastElementRef = useCallback(
    (node: HTMLDivElement | null) => {
      if (isFetchingNextPage) return;
      if (observerRef.current) observerRef.current.disconnect();
      
      observerRef.current = new IntersectionObserver((entries) => {
        if (entries[0].isIntersecting && hasNextPage) {
          fetchNextPage();
        }
      });
      
      if (node) observerRef.current.observe(node);
    },
    [isFetchingNextPage, hasNextPage, fetchNextPage]
  );
  
  return (
    <div>
      {data?.pages.map((page, i) => (
        <React.Fragment key={i}>
          {page.items.map((item, j) => {
            const isLast =
              i === data.pages.length - 1 && j === page.items.length - 1;
            
            return (
              <DatasetCard
                key={item.id}
                data={item}
                ref={isLast ? lastElementRef : null}
              />
            );
          })}
        </React.Fragment>
      ))}
      {isFetchingNextPage && <Skeleton />}
    </div>
  );
}
```

---

## 2. AgentFactory

### 2.1 å¾®å‰ç«¯æ¶æ„ï¼ˆWujieï¼‰

#### ä¸»åº”ç”¨é…ç½®

```typescript
// ä¸»åº”ç”¨ - app/agent-factory/page.tsx
'use client';
import WujieReact from 'wujie-react';
import { useTheme } from 'next-themes';
import { useTranslation } from 'react-i18next';
import { useAuth } from '@/hooks/use-auth';

export default function AgentFactoryPage() {
  const { theme } = useTheme();
  const { i18n } = useTranslation();
  const { token, user } = useAuth();
  
  return (
    <WujieReact
      name="agentfactory"
      url={process.env.NEXT_PUBLIC_AGENT_FACTORY_URL}
      props={{
        theme,
        language: i18n.language,
        token,
        user,
      }}
      alive={true} // ä¿æ´»
      fetch={(url, options) => {
        // è‡ªå®šä¹‰è¯·æ±‚ï¼ˆå¤„ç†è·¨åŸŸã€è®¤è¯ç­‰ï¼‰
        return fetch(url, {
          ...options,
          headers: {
            ...options?.headers,
            Authorization: `Bearer ${token}`,
          },
        });
      }}
    />
  );
}
```

#### å­åº”ç”¨é›†æˆ

```typescript
// å­åº”ç”¨ - src/main.tsx
import { createRoot } from 'react-dom/client';
import App from './App';

// æ£€æµ‹æ˜¯å¦åœ¨ Wujie ç¯å¢ƒ
const isWujie = window.__POWERED_BY_WUJIE__;

// ç”Ÿå‘½å‘¨æœŸ
if (isWujie) {
  // å¾®å‰ç«¯æ¨¡å¼
  if (window.__WUJIE_MOUNT__) {
    window.__WUJIE_MOUNT__();
  }
  
  if (window.__WUJIE_UNMOUNT__) {
    window.__WUJIE_UNMOUNT__();
  }
} else {
  // ç‹¬ç«‹æ¨¡å¼
  const container = document.getElementById('root');
  const root = createRoot(container!);
  root.render(<App />);
}

// App ç»„ä»¶ä¸­å¤„ç† props
function App() {
  const [config, setConfig] = useState(getConfig());
  
  useEffect(() => {
    if (window.$wujie) {
      // ç›‘å¬ props å˜åŒ–
      const handlePropsChange = () => {
        const props = window.$wujie?.props;
        if (props) {
          // åŒæ­¥ä¸»é¢˜
          if (props.theme) {
            document.documentElement.setAttribute('data-theme', props.theme);
          }
          
          // åŒæ­¥è¯­è¨€
          if (props.language) {
            i18n.changeLanguage(props.language);
          }
          
          // åŒæ­¥ Token
          if (props.token) {
            authStore.setToken(props.token);
          }
        }
      };
      
      // åˆå§‹åŒ–
      handlePropsChange();
      
      // ç›‘å¬å˜åŒ–ï¼ˆè½®è¯¢æ£€æŸ¥ï¼‰
      const interval = setInterval(handlePropsChange, 100);
      
      return () => clearInterval(interval);
    }
  }, []);
  
  return <Router />;
}

function getConfig() {
  if (window.$wujie?.props) {
    return window.$wujie.props;
  }
  
  // ç‹¬ç«‹è¿è¡Œ
  return {
    theme: localStorage.getItem('theme') || 'light',
    language: localStorage.getItem('language') || 'zh',
    token: localStorage.getItem('token'),
  };
}
```

#### äº‹ä»¶é€šä¿¡

```typescript
// å­åº”ç”¨å‘é€äº‹ä»¶
window.$wujie?.bus.$emit('agent:route-change', {
  path: '/workflow/edit/123',
  title: 'ç¼–è¾‘å·¥ä½œæµ',
});

window.$wujie?.bus.$emit('agent:data-updated', {
  type: 'workflow',
  id: '123',
});

// ä¸»åº”ç”¨ç›‘å¬äº‹ä»¶
const bus = WujieReact.bus;

bus.$on('agent:route-change', (data) => {
  // æ›´æ–°é¢åŒ…å±‘
  updateBreadcrumbs(data);
});

bus.$on('agent:data-updated', (data) => {
  // åˆ·æ–°ç›¸å…³æ•°æ®
  queryClient.invalidateQueries(['workflows']);
});
```

---

### 2.2 æ€§èƒ½ä¼˜åŒ–ï¼ˆHTTP è¯·æ±‚å‡å°‘ 90%+ï¼‰

#### Vite é…ç½®ä¼˜åŒ–

```typescript
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { visualizer } from 'rollup-plugin-visualizer';

export default defineConfig({
  plugins: [
    react(),
    visualizer({ open: true }), // æ„å»ºåˆ†æ
  ],
  
  build: {
    rollupOptions: {
      output: {
        // æ‰‹åŠ¨åˆ†åŒ…
        manualChunks: (id) => {
          // ç¬¬ä¸‰æ–¹åº“
          if (id.includes('node_modules')) {
            // React ç›¸å…³
            if (id.includes('react') || id.includes('react-dom')) {
              return 'react-vendor';
            }
            
            // UI åº“
            if (id.includes('@mui') || id.includes('@emotion')) {
              return 'mui-vendor';
            }
            
            // ReactFlow
            if (id.includes('reactflow')) {
              return 'reactflow-vendor';
            }
            
            // Redux
            if (id.includes('redux') || id.includes('@reduxjs')) {
              return 'redux-vendor';
            }
            
            // å…¶ä»–ç¬¬ä¸‰æ–¹åº“
            return 'vendor';
          }
          
          // ä¸šåŠ¡ä»£ç æŒ‰è·¯ç”±åˆ†ç»„
          if (id.includes('/src/pages/')) {
            const match = id.match(/\/pages\/([^/]+)/);
            if (match) {
              return `page-${match[1]}`;
            }
          }
          
          // é€šç”¨ç»„ä»¶
          if (id.includes('/src/components/')) {
            return 'components';
          }
        },
      },
    },
    
    // ä»£ç åˆ†å‰²é˜ˆå€¼
    chunkSizeWarningLimit: 1000,
    
    // å‹ç¼©
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true, // ç§»é™¤ console
        drop_debugger: true,
      },
    },
  },
  
  // ä¾èµ–é¢„æ„å»º
  optimizeDeps: {
    include: [
      'react',
      'react-dom',
      '@mui/material',
      'reactflow',
      '@reduxjs/toolkit',
    ],
  },
});
```

#### è·¯ç”±æ‡’åŠ è½½

```typescript
// src/App.tsx
import { lazy, Suspense } from '