# 陈康 - 前端工程师面试准备核心指南

## 📋 个人定位

**核心标签**：3年+ 前端 | 1年 AI 平台经验 | 性能优化专家 | 微前端架构

**技术亮点**：
- React/Next.js 技术栈专家
- 微前端架构（Wujie）实战经验
- 极致性能优化（HTTP 请求减少 90%+）
- AI 平台研发经验（标注工具、智能代理）
- RBAC 权限系统（70+ 权限点）

---

## 🎯 核心项目速览

### 项目 1：AI 智能开发平台（2024.10 - 至今）
**角色**：前端负责人，主导 AI 数据标注子系统
**核心成果**：
- 标注响应时间优化 61%（180ms → 70ms）
- 智能标注效率提升 3-5 倍
- 视频标注流畅度提升 50%
- 列表刷新延迟降低 70%

### 项目 2：AgentFactory AI 代理平台（2024.10 - 至今）
**角色**：前端负责人，主导微前端集成与性能优化
**核心成果**：
- HTTP 请求减少 90%+（数千 → 20-30 个）
- 首屏加载时间缩短 50%+
- 支持 500+ 节点的工作流编辑
- 主子应用同步 100ms 内完成

### 项目 3：河北银行国际业务系统（2021-2024）
**角色**：前端开发
**核心成果**：
- 首页加载时间减少 30%
- 资源加载时间减少 30%

### 项目 4：友利银行外汇监测系统（2021-2024）
**角色**：前端开发
**核心成果**：
- 首屏渲染时间从 3s → 1s
- 报表加载时间减少 25%
- 服务器负载降低 20%

---

## 🌟 核心亮点 STAR 模板

### 亮点 1：HTTP 请求优化 - 减少 90%+

**Situation（背景）**：
AgentFactory 项目上线后，用户反馈首次加载极慢，打开 DevTools 发现有**数千个 HTTP 请求**，严重影响用户体验。

**Task（任务）**：
需要快速定位问题并优化，将请求数降到合理范围（< 50个），同时不影响功能。

**Action（行动）**：
1. **问题分析**：
   - 使用 Vite Build Analyzer 分析构建产物
   - 发现每个小模块都单独打包成一个 chunk
   - 动态导入策略配置不合理，导致过度分割

2. **智能代码分割策略**：
   ```typescript
   // vite.config.ts
   build: {
     rollupOptions: {
       output: {
         manualChunks: (id) => {
           // 第三方库统一打包
           if (id.includes('node_modules')) {
             if (id.includes('react') || id.includes('react-dom')) {
               return 'react-vendor';
             }
             if (id.includes('@mui')) {
               return 'mui-vendor';
             }
             if (id.includes('reactflow')) {
               return 'reactflow-vendor';
             }
             return 'vendor';
           }
           
           // 业务代码按路由分组
           if (id.includes('/src/pages/')) {
             const match = id.match(/\/pages\/([^/]+)/);
             return match ? `page-${match[1]}` : 'common';
           }
         },
       },
     },
   }
   ```

3. **路由级懒加载优化**：
   - 将页面级组件改为动态导入
   - 预加载关键路由（用户高频访问）
   - 非关键组件延迟加载

4. **依赖预构建**：
   - 配置 Vite `optimizeDeps`，预构建大型依赖
   - 减少运行时模块解析

**Result（结果）**：
- ✅ HTTP 请求从**数千个降到 20-30 个**（**减少 90%+**）
- ✅ 首屏加载时间**缩短 50%+**
- ✅ Bundle 大小**减少 30-40%**
- ✅ 用户反馈加载速度明显提升

---

### 亮点 2：标注工具性能优化 - 响应时间降低 61%

**Situation（背景）**：
AI 数据标注是 AI 工作流的起点，用户需要快速标注大量数据。初版标注工具操作延迟明显（180ms），快速标注时有卡顿，影响效率。

**Task（任务）**：
优化标注工具响应时间，目标降到 100ms 以下，让用户感觉流畅。

**Action（行动）**：
1. **性能分析**：
   - Chrome DevTools Performance 录制操作过程
   - 发现 `renderAll()` 占用 40% 时间（全量重绘）
   - 事件处理占用 30%（监听器过多）
   - 序列化占用 20%（阻塞主线程）

2. **渲染优化 - 按需渲染**：
   ```typescript
   class OptimizedCanvas {
     private dirtyObjects = new Set<fabric.Object>();
     
     markDirty(obj: fabric.Object) {
       this.dirtyObjects.add(obj);
       this.requestRender();
     }
     
     private requestRender() {
       requestAnimationFrame(() => {
         if (this.dirtyObjects.size > 0) {
           canvas.renderOnAddRemove = false;
           canvas.renderAll();
           this.dirtyObjects.clear();
         }
       });
     }
   }
   ```

3. **事件优化 - 统一管理 + 防抖**：
   ```typescript
   class AnnotationEventManager {
     private debounceTimer: NodeJS.Timeout | null = null;
     
     constructor(private canvas: fabric.Canvas) {
       this.canvas.on('object:modified', (e) => {
         this.debounceSave(e.target);
       });
     }
     
     private debounceSave(target: fabric.Object) {
       if (this.debounceTimer) clearTimeout(this.debounceTimer);
       this.debounceTimer = setTimeout(() => {
         this.saveAnnotation(target);
       }, 300);
     }
   }
   ```

4. **对象池 - 减少创建销毁**：
   - 实现 Fabric 对象池，复用对象
   - 初始化时预创建 20 个常用对象

5. **异步优化**：
   - 使用 `requestIdleCallback` 延迟非关键序列化
   - Web Worker 处理复杂计算

**Result（结果）**：
- ✅ 响应时间从 180ms → **70ms**（**降低 61%**）
- ✅ FPS 从 30 → 55+
- ✅ 无内存泄漏，长时间标注流畅

---

### 亮点 3：微前端架构集成 - 100ms 内同步

**Situation（背景）**：
AgentFactory 需要作为子应用嵌入到主 AI 平台，同时支持独立部署。需要实现主子应用间的主题、语言、Token 同步。

**Task（任务）**：
1. 设计微前端集成方案
2. 实现主子应用通信机制
3. 保证同步延迟 < 200ms
4. 兼容独立/嵌入式两种部署模式

**Action（行动）**：
1. **技术选型 - Wujie**：
   - 对比 qiankun、Micro-App、Wujie
   - 选择 Wujie：隔离性好、通信简单、性能优秀

2. **事件总线设计**：
   ```typescript
   // 主应用
   <WujieApp
     name="agentfactory"
     url="https://agent.example.com"
     props={{
       theme: currentTheme,
       language: currentLang,
       token: userToken,
     }}
   />
   
   // 监听子应用事件
   bus.$on('agent:route-change', (route) => {
     updateBreadcrumbs(route);
   });
   
   // 子应用
   window.$wujie?.props // 接收主应用数据
   
   // 发送事件到主应用
   window.$wujie?.bus.$emit('agent:route-change', {
     path: '/workflow/edit',
   });
   ```

3. **响应式同步机制**：
   ```typescript
   // 子应用监听 props 变化
   useEffect(() => {
     if (window.$wujie?.props) {
       const { theme, language, token } = window.$wujie.props;
       
       // 同步主题
       if (theme !== currentTheme) {
         setTheme(theme);
       }
       
       // 同步语言
       if (language !== currentLang) {
         i18n.changeLanguage(language);
       }
       
       // 同步 Token
       if (token !== currentToken) {
         updateToken(token);
       }
     }
   }, [window.$wujie?.props]);
   ```

4. **独立/嵌入式兼容**：
   ```typescript
   // 环境检测
   const isEmbedded = window.$wujie !== undefined;
   
   if (isEmbedded) {
     // 从主应用获取配置
     config = window.$wujie.props;
   } else {
     // 独立运行，使用本地配置
     config = getLocalConfig();
   }
   ```

**Result（结果）**：
- ✅ 主子应用同步延迟 **< 100ms**
- ✅ 兼容独立/嵌入式部署（**灵活性提升 100%**）
- ✅ 主题/语言切换无闪烁
- ✅ 用户体验一致

---

### 亮点 4：智能标注效率提升 3-5 倍

**Situation（背景）**：
传统手动标注耗时长，一张图片需要 3-5 分钟。项目需要集成 SAM、YOLO 等智能标注工具辅助用户。

**Task（任务）**：
1. 集成三种智能标注工具
2. 与现有系统解耦，易于扩展
3. 统一用户体验

**Action（行动）**：
1. **架构设计 - 策略模式**：
   ```typescript
   interface ISmartAnnotationTool {
     name: string;
     type: 'segmentation' | 'detection' | 'tracking';
     annotate(image: ImageData, options?: any): Promise<Annotation[]>;
   }
   
   class SmartAnnotationManager {
     private tools = new Map<string, ISmartAnnotationTool>();
     
     register(tool: ISmartAnnotationTool) {
       this.tools.set(tool.name, tool);
     }
     
     async execute(toolName: string, image: ImageData) {
       const tool = this.tools.get(toolName);
       const annotations = await tool.annotate(image);
       this.eventBus.emit('annotation:created', annotations);
       return annotations;
     }
   }
   ```

2. **事件解耦 - 发布订阅**：
   ```typescript
   // 工具只负责生成标注
   eventBus.emit('annotation:created', annotations);
   
   // 画布监听渲染
   eventBus.on('annotation:created', renderAnnotations);
   
   // 数据模块监听保存
   eventBus.on('annotation:created', saveAnnotations);
   ```

3. **工具集成**：
   - **SAM**：交互式分割，用户点击生成轮廓
   - **YOLO**：一键检测所有目标
   - **自研工具**：边缘检测

**Result（结果）**：
- ✅ 标注时间从 3-5 分钟 → **30-60 秒**（**提升 3-5 倍**）
- ✅ 支持 3 种工具，新增工具只需 2 小时
- ✅ AI 准确率 85%+

---

### 亮点 5：首屏性能优化 - 3s → 1s

**Situation（背景）**：
友利银行外汇监测系统首屏加载慢（3s+），用户体验差，尤其在网络不好时更明显。

**Task（任务）**：
优化首屏加载时间，目标 1s 内完成渲染。

**Action（行动）**：
1. **性能分析 - LightHouse**：
   - LCP（最大内容绘制）：3.2s
   - FCP（首次内容绘制）：2.1s
   - TTI（可交互时间）：4.5s

2. **构建优化**：
   - Webpack SplitChunksPlugin 代码分割
   - 路由懒加载，首屏只加载必要代码
   - Tree Shaking 移除未使用代码

3. **资源优化**：
   - 图片压缩（TinyPNG）+ WebP 格式
   - 小图标内联为 Base64（< 4KB）
   - 字体子集化，只加载中文常用字

4. **CDN + 缓存**：
   - 静态资源上传 CDN
   - Nginx 配置长期缓存（1 年）
   - HTML 设置 no-cache，确保更新

5. **代码优化**：
   - 组件懒加载（React.lazy）
   - 防抖/节流减少计算
   - 虚拟滚动（大列表）

**Result（结果）**：
- ✅ 首屏渲染从 3s → **< 1s**
- ✅ LCP 优化到 1.2s
- ✅ 报表加载时间减少 25%
- ✅ 服务器负载降低 20%

---

## 📝 高频面试问题 & 回答要点

### 一、项目背景问题

#### Q1: 简单介绍一下你自己
**回答框架**：基本信息 + 工作经验 + 核心技能 + 项目亮点

**示例回答**：
> "你好，我是陈康，有 3 年多的前端开发经验，主要技术栈是 React 和 Next.js。
>
> 最近一年我在道通科技负责 AI 平台的前端研发，主导了两个核心项目：
> 1. **AI 智能开发平台**：负责数据标注子系统，通过性能优化将标注响应时间降低了 61%
> 2. **AgentFactory**：负责微前端集成和性能优化，将 HTTP 请求减少了 90%+
>
> 之前两年在中电金信负责银行系统开发，主要做性能优化和组件化建设。
>
> 我比较擅长性能优化和复杂交互的实现，也有微前端架构、权限系统等方面的经验。"

---

#### Q2: 介绍一下你最有挑战的项目
**选择**：AgentFactory HTTP 请求优化

**STAR 回答**：（参考亮点 1）

**追问应对**：
- Q: 为什么会有数千个请求？
  - A: Vite 默认配置过度分割，每个小模块都单独打包
  
- Q: 如何确定分割策略？
  - A: 分析依赖关系图，按业务模块和访问频率分组

- Q: 优化后有什么副作用吗？
  - A: 单个 chunk 变大，但通过缓存和 CDN 解决

---

### 二、技术深度问题

#### Q1: 微前端架构中，主子应用如何通信？

**回答要点**：
1. **通信方式**：Props 传递、事件总线、全局状态
2. **数据同步**：响应式更新机制
3. **性能考虑**：避免频繁通信、批量更新

**示例回答**：
> "我们使用 Wujie 微前端方案，主要有三种通信方式：
>
> **1. Props 传递（主 → 子）**：
> - 主应用通过 `<WujieApp props={...}>` 传递数据
> - 子应用通过 `window.$wujie?.props` 接收
> - 适合传递配置、Token、主题等
>
> **2. 事件总线（双向）**：
> - 使用 Wujie 提供的 `bus.$emit` 和 `bus.$on`
> - 子应用向主应用报告路由变化、数据更新等
> - 主应用可以调用子应用方法（如刷新数据）
>
> **3. 全局状态（共享）**：
> - 用户信息、权限等通过全局状态共享
> - 避免重复请求
>
> **性能优化**：
> - 使用防抖避免频繁同步
> - 批量更新减少通信次数
> - 关键数据（Token）变化才触发更新"

---

#### Q2: Fabric.js 如何实现高性能渲染？

**回答要点**：
1. 按需渲染 vs 全量渲染
2. 事件优化
3. 对象池
4. 离屏 Canvas

**示例回答**：
> "Fabric.js 的性能优化主要从几个方面入手：
>
> **1. 按需渲染**：
> - 默认 `renderAll()` 会重绘所有对象
> - 我们引入脏对象标记，只重绘变化的对象
> - 使用 `requestAnimationFrame` 合并渲染请求
>
> **2. 事件优化**：
> - 统一事件管理，避免每个对象独立监听
> - 操作防抖（300ms），减少保存频率
> - 鼠标移动事件节流
>
> **3. 对象池**：
> - 预创建常用对象（矩形、圆形）
> - 删除时放回对象池，避免频繁创建销毁
>
> **4. 离屏 Canvas**（视频标注）：
> - 在离屏 Canvas 预渲染帧
> - 减少主 Canvas 的渲染压力
>
> **效果**：响应时间从 180ms → 70ms，FPS 从 30 → 55+"

---

#### Q3: React Query 的缓存机制是怎样的？

**回答要点**：
1. 缓存层级（Fresh、Stale、Inactive）
2. 自动刷新策略
3. 乐观更新

**示例回答**：
> "React Query 使用多层缓存机制：
>
> **缓存层级**：
> 1. **Fresh（新鲜）**：`staleTime` 内，直接返回缓存，不请求
> 2. **Stale（过期）**：超过 `staleTime`，返回缓存 + 后台重新请求
> 3. **Inactive（未使用）**：组件卸载后，`cacheTime` 内保留缓存
> 4. **GC**：超过 `cacheTime`，清除缓存
>
> **自动刷新**：
> - 窗口聚焦时刷新（`refetchOnWindowFocus`）
> - 网络重连时刷新（`refetchOnReconnect`）
> - 定时轮询（`refetchInterval`）
>
> **乐观更新**：
> - 操作时立即更新 UI（如删除）
> - 后台调用 API
> - 失败时自动回滚
>
> **优势**：
> - 减少不必要的请求（缓存命中）
> - 操作即时反馈（乐观更新）
> - 数据始终最新（自动刷新）
>
> 在数据标注项目中，我们设置 5 分钟 `staleTime`，列表刷新延迟降低了 70%。"

---

### 三、技术选型问题

#### Q1: 为什么选择 Wujie 而不是 qiankun？

**回答框架**：
1. 对比方案优缺点
2. 项目需求匹配
3. 最终选择理由

**示例回答**：
> "我们评估了三个方案：
>
> **qiankun**：
> - ✅ 生态成熟，社区活跃
> - ✅ 阿里维护，稳定性好
> - ❌ 基于 single-spa，样式隔离需要额外配置
> - ❌ 子应用改造成本较高
>
> **Micro-App**：
> - ✅ 基于 Web Components，隔离性好
> - ✅ 接入简单
> - ❌ 浏览器兼容性问题（IE）
> - ❌ 社区相对较小
>
> **Wujie**：
> - ✅ iframe + Web Components，天然隔离
> - ✅ 子应用零改造（我们需要独立部署）
> - ✅ 性能优秀（预加载、保活）
> - ✅ 通信简单（props + 事件总线）
> - ❌ 社区相对较新
>
> **最终选择 Wujie**：
> 1. 子应用需要独立部署，Wujie 零改造成本最低
> 2. 样式隔离是硬需求，Wujie 天然支持
> 3. 性能优秀，满足我们的场景
> 4. 腾讯维护，稳定性有保障"

---

#### Q2: 为什么用 Vite 而不是 Webpack？

**示例回答**：
> "AgentFactory 项目选择 Vite 主要考虑：
>
> **开发体验**：
> - Vite 启动速度极快（< 1s vs Webpack 30s+）
> - HMR 更快更稳定
> - 开发效率提升明显
>
> **构建性能**：
> - 使用 esbuild 预构建依赖，比 Webpack 快 10-100 倍
> - 生产构建基于 Rollup，产物更小
>
> **生态兼容**：
> - React、TypeScript、CSS Modules 等开箱即用
> - 插件生态逐渐成熟
>
> **项目匹配**：
> - 新项目，没有 Webpack 历史包袱
> - 团队对 Vite 比较熟悉
> - 不需要特殊的 Webpack loader
>
> **潜在问题**：
> - 生产环境用 Rollup，开发用 esbuild，可能有差异
> - 解决：充分测试，CI 环境构建验证"

---

### 四、性能优化问题

#### Q1: 如何分析性能瓶颈？

**回答框架**：
1. 工具使用
2. 指标分析
3. 定位问题
4. 验证效果

**示例回答**：
> "我通常用以下工具和方法：
>
> **1. Chrome DevTools Performance**：
> - 录制用户操作，分析火焰图
> - 定位耗时长的函数（JS 执行、渲染）
> - 查看 FPS、内存使用
>
> **2. LightHouse**：
> - 分析 LCP、FCP、TTI 等核心指标
> - 给出优化建议（图片压缩、代码分割）
>
> **3. Network 面板**：
> - 查看请求数量、大小、时间
> - 定位慢请求、重复请求
> - 检查缓存策略
>
> **4. React DevTools Profiler**：
> - 分析组件渲染次数和耗时
> - 找出不必要的重渲染
>
> **5. Webpack Bundle Analyzer**：
> - 分析打包产物大小
> - 找出体积大的依赖
>
> **案例**：
> 在标注工具优化中：
> 1. Performance 发现 `renderAll()` 占用 40% 时间
> 2. Profiler 发现画布组件频繁重渲染
> 3. 优化：按需渲染 + React.memo
> 4. 验证：响应时间降低 61%"

---

#### Q2: 如何优化长列表性能？

**回答要点**：
1. 虚拟滚动
2. 分页加载
3. 懒渲染
4. 防抖节流

**示例回答**：
> "长列表优化主要从几个方面：
>
> **1. 虚拟滚动（核心）**：
> - 只渲染可见区域的 DOM 节点
> - 使用 `react-window` 或 `@tanstack/react-virtual`
> - 1000 条数据实际只渲染 10-20 个节点
>
> **2. 分页加载**：
> - 无限滚动（Intersection Observer）
> - React Query 的 `useInfiniteQuery`
> - 触底自动加载下一页
>
> **3. 懒渲染**：
> - 非关键内容延迟渲染
> - `requestIdleCallback` 在空闲时渲染
>
> **4. 防抖节流**：
> - 搜索输入防抖（300ms）
> - 滚动事件节流（100ms）
>
> **5. 数据优化**：
> - React Query 缓存，避免重复请求
> - 后端分页，不要一次返回所有数据
>
> **效果**：
> 在数据集列表中，支持 1000+ 数据流畅展示，FPS 稳定 60。"

---

### 五、项目经验问题

#### Q1: 你在团队中的角色是什么？

**回答要点**：
1. 技术负责人 vs 开发者
2. 具体职责
3. 团队协作

**示例回答**：
> "在不同项目中角色不同：
>
> **AgentFactory 和 AI 平台**（道通科技）：
> - 角色：**前端负责人**
> - 职责：
>   - 技术选型和架构设计
>   - 核心功能开发（标注工具、微前端集成）
>   - 性能优化（HTTP 请求优化、加载优化）
>   - Code Review 和技术指导
>   - 与后端、AI 团队协作定义接口
>
> **银行项目**（中电金信）：
> - 角色：**前端开发**
> - 职责：
>   - 需求开发和迭代
>   - 性能优化和组件封装
>   - Bug 修复和维护
>
> **团队协作**：
> - 主动推动技术改进（如 Turbo monorepo）
> - 分享技术经验（性能优化、工程化）
> - 帮助团队成员解决技术难题"

---

#### Q2: 遇到技术难题如何解决？

**STAR 示例**（HTTP 请求优化）：

**Situation**：
AgentFactory 上线后发现数千个 HTTP 请求，严重影响性能。

**Task**：
快速定位问题并解决，时间紧迫（一周内必须上线）。

**Action**：
1. **快速定位**：
   - 打开 DevTools Network 面板，截图记录请求数量
   - 使用 Vite Build Analyzer 分析构建产物
   - 发现过度代码分割导致

2. **方案调研**：
   - 查阅 Vite 官方文档（manualChunks）
   - 参考 Vite 社区最佳实践
   - 对比 Webpack SplitChunksPlugin 配置

3. **实施优化**：
   - 编写 manualChunks 配置
   - 本地测试验证效果
   - 灰度发布，监控线上数据

4. **效果验证**：
   - LightHouse 测试性能提升
   - 用户反馈收集
   - 调整配置（多次迭代）

**Result**：
一周内完成优化，请求数降到 20-30 个，用户体验显著提升。

**学习到什么**：
- 构建工具的配置对性能影响巨大
- 性能优化要基于数据，不能凭感觉
- 快速迭代比一次做到完美更重要

---

## 🎓 技术深度准备清单

### 必须掌握的技术点

#### 1. Fabric.js（AI 平台）
- [ ] Canvas 基础 API
- [ ] Fabric 对象模型（Object、Canvas、Group）
- [ ] 事件系统（mouse、object、selection）
- [ ] 渲染机制（renderAll、requestRenderAll）
- [ ] 性能优化（对象池、按需渲染）

#### 2. React Query（数据管理）
- [ ] 缓存机制（Fresh、Stale、Inactive、GC）
- [ ] 自动刷新策略（refetchOnWindowFocus、refetchInterval）
- [ ] 乐观更新（onMutate、onError、onSettled）
- [ ] 无限滚动（useInfiniteQuery、getNextPageParam）
- [ ] 请求去重和防抖

#### 3. Wujie 微前端（AgentFactory）
- [ ] 微前端架构对比（qiankun、Micro-App、Wujie）
- [ ] 样式隔离原理（iframe、Shadow DOM）
- [ ] 通信机制（Props、事件总线、全局状态）
- [ ] 生命周期（mounted、unmounted、activated）
- [ ] 性能优化（预加载、保活）

#### 4. Vite 构建优化（AgentFactory）
- [ ] Vite vs Webpack 差异
- [ ] 依赖预构建（optimizeDeps）
- [ ] 代码分割（manualChunks）
- [ ] 资源处理（assetsInlineLimit）
- [ ] 生产构建（Rollup 配置）

#### 5. 性能优化（所有项目）
- [ ] 性能指标（LCP、FCP、TTI、FID、CLS）
- [ ] 分析工具（Chrome DevTools、LightHouse、Bundle Analyzer）
- [ ] 优化策略（代码分割、懒加载、缓存、CDN）
- [ ] 渲染优化（虚拟滚动、防抖节流、React.memo）

#### 6. RBAC 权限系统（AI 平台）
- [ ] RBAC 模型（User、Role、Permission）
- [ ] 权限检查机制（前端、后端、路由）
- [ ] 多租户隔离（tenant_id、数据隔离）
- [ ] 细粒度权限（70+ 权限点的设计）

---

## 📋 面试前准备事项

### 1 天前
- [ ] 通读本文档 2 遍
- [ ] 背熟 5 个核心亮点的 STAR 回答
- [ ] 准备 3-5 个技术难题案例
- [ ] 准备 2-3 个问题问面试官

### 面试当天
- [ ] 回顾核心数字（61%、90%+、50%、70%、3-5倍）
- [ ] 回顾技术栈（React 18、Next.js 14、Vite、Wujie、Fabric.js）
- [ ] 准备纸笔（画架构图）
- [ ] 调试好网络和设备

### 面试话术提示
- **自信但不夸大**：用数据说话，避免"非常好""很厉害"等模糊词
- **结构化表达**：使用 STAR 法则，先说结论再说过程
- **技术深度**：准备被追问 2-3 层，不要浮于表面
- **诚实态度**：不会的直接说不会，但表达学习意愿

---

## 🎯 给面试官的问题（反问环节）

### 技术相关
1. "团队目前的技术栈是什么？未来有什么技术规划？"
2. "团队如何保证代码质量？有 Code Review 流程吗？"
3. "前端团队规模多大？如何分工协作？"

### 项目相关
4. "这个岗位主要负责哪些项目？技术挑战是什么？"
5. "团队有性能优化的需求吗？目前的痛点是什么？"

### 成长相关
6. "公司对工程师的成长有什么支持？（培训、技术分享）"
7. "团队的技术氛围怎么样？鼓励技术创新吗？"

---

**祝面试顺利！** 🚀

记住：**自信、真实、有条理**是面试成功的关键。
