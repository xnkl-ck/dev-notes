# 只读模式实现最佳实践指南

> 基于已发布Agent只读保护功能的实战经验总结

## 📋 目录

- [功能概述](#功能概述)
- [核心思路](#核心思路)
- [架构设计](#架构设计)
- [关键实现](#关键实现)
- [设计决策](#设计决策)
- [代码示例](#代码示例)
- [最佳实践](#最佳实践)
- [常见问题](#常见问题)

---

## 功能概述

### 业务场景
当Agent发布到生产环境后（`versionType === 'PUBLISH'`），需要防止用户误操作修改，确保生产环境的稳定性。

### 核心要求
1. ✅ 禁止所有编辑操作（拖拽、连接、删除、修改）
2. ✅ 允许查看和复制（合理的只读操作）
3. ✅ 清晰的视觉提示（让用户知道是只读状态）
4. ✅ 简洁的用户体验（不显示不可用的功能）

---

## 核心思路

### 🎯 三层防护策略

```
┌────────────────────────────────────────┐
│  第1层：状态判断                        │
│  const isPublishedVersion =            │
│    chatflow?.versionType === 'PUBLISH' │
└────────────────────────────────────────┘
                 ↓
┌────────────────────────────────────────┐
│  第2层：UI拦截                          │
│  • 隐藏编辑按钮                         │
│  • 操作时显示提示                       │
│  • 添加视觉标识                         │
└────────────────────────────────────────┘
                 ↓
┌────────────────────────────────────────┐
│  第3层：底层禁用                        │
│  • nodesDraggable={false}              │
│  • nodesConnectable={false}            │
│  • deleteKeyCode={null}                │
└────────────────────────────────────────┘
```

**为什么需要三层？**
- 第1层：提供统一的判断逻辑
- 第2层：提供友好的用户体验
- 第3层：确保安全性兜底

---

## 架构设计

### 1. 状态管理 - Redux单一数据源

```javascript
// ✅ 最佳实践：从Redux获取状态
const chatflow = useSelector((state) => state.canvas.chatflow)
const isPublishedVersion = chatflow?.versionType === 'PUBLISH'
```

**为什么这样设计？**

| 方案 | 优点 | 缺点 | 选择 |
|------|------|------|------|
| Props传递 | 明确 | 层级深时繁琐 | ❌ |
| Context | 全局共享 | 需要Provider包裹 | ❌ |
| Redux | 统一管理 | 需要Redux基础 | ✅ |

**设计原则：**
- ✅ 单一数据源（Single Source of Truth）
- ✅ 状态集中管理
- ✅ 避免状态不一致

### 2. 保护范围 - 全面覆盖编辑入口

```
画布操作                     节点操作
├─ 拖拽节点 ✓               ├─ 右键菜单 ✓
├─ 连接节点 ✓               │  ├─ 复制（隐藏）
├─ 添加节点 ✓               │  └─ 删除（隐藏）
├─ 删除节点 ✓               ├─ 双击编辑 ✓
└─ 修改连接 ✓               └─ 参数修改 ✓

工具栏                       视觉提示
├─ 保存按钮（隐藏）          ├─ 锁图标 ✓
├─ 删除按钮（隐藏）          └─ 隐藏侧边栏 ✓
├─ 存档按钮（隐藏）
└─ 发布按钮（隐藏）
```

---

## 关键实现

### 1. 画布层保护

```javascript
// Canvas.jsx
const AgentflowCanvas = () => {
    const chatflow = useSelector((state) => state.canvas.chatflow)
    const isPublishedVersion = chatflow?.versionType === 'PUBLISH'

    // ✅ 关键1: 清除dirty状态（防止误导）
    useEffect(() => {
        if (isPublishedVersion && canvasDataStore.isDirty) {
            dispatch({ type: REMOVE_DIRTY })
        }
    }, [isPublishedVersion, canvasDataStore.isDirty, dispatch])

    // ✅ 关键2: 操作拦截 + 友好提示
    const onConnect = (params) => {
        if (isPublishedVersion) {
            enqueueSnackbar({
                message: t('messages.publishedVersionReadOnly'),
                options: { variant: 'warning' }
            })
            return  // 提前返回，阻止后续逻辑
        }
        // ... 正常连接逻辑
    }

    // ✅ 关键3: ReactFlow底层禁用
    return (
        <ReactFlow
            nodesDraggable={!isPublishedVersion}
            nodesConnectable={!isPublishedVersion}
            deleteKeyCode={isPublishedVersion ? null : ['Delete', 'Backspace']}
            elementsSelectable={true}  // 仍允许选中查看
        />
    )
}
```

**实现要点：**
1. **多层防护**：UI拦截 + 底层禁用
2. **用户友好**：提示原因而非静默失败
3. **状态同步**：自动清除dirty避免误导

### 2. 节点菜单保护

```javascript
// AgentFlowNode.jsx / IterationNode.jsx / StickyNote.jsx
const AgentFlowNode = ({ data }) => {
    const chatflow = useSelector((state) => state.canvas.chatflow)
    const isPublishedVersion = chatflow?.versionType === 'PUBLISH'

    return (
        <MenuList>
            {/* ✅ 关键：条件渲染而非禁用 */}
            {!isPublishedVersion && (
                <MenuItem onClick={() => duplicateNode(data.id)}>
                    复制
                </MenuItem>
            )}
            
            {!isPublishedVersion && (
                <MenuItem onClick={() => deleteNode(data.id)}>
                    删除
                </MenuItem>
            )}
            
            {/* ✅ 信息按钮始终显示 */}
            <MenuItem onClick={() => setShowInfoDialog(true)}>
                信息
            </MenuItem>
        </MenuList>
    )
}
```

**为什么用条件渲染而非disabled？**

```javascript
// ❌ 方案A：禁用状态（不推荐）
<MenuItem 
    disabled={isPublishedVersion}
    onClick={...}
    sx={{
        opacity: isPublishedVersion ? 0.5 : 1,
        cursor: isPublishedVersion ? 'not-allowed' : 'pointer',
        // ... 更多样式处理
    }}
>
    删除
</MenuItem>

// ✅ 方案B：条件渲染（推荐）
{!isPublishedVersion && (
    <MenuItem onClick={...}>
        删除
    </MenuItem>
)}
```

**对比分析：**

| 维度 | disabled方案 | 条件渲染方案 |
|------|-------------|-------------|
| 代码量 | 多（需处理样式） | 少 |
| 用户体验 | 混淆（为什么显示灰色？） | 清晰（不显示就是不能用） |
| 维护性 | 复杂 | 简单 |
| 视觉干扰 | 有（灰色按钮） | 无 |

### 3. 顶部工具栏保护

```javascript
// CanvasHeader.jsx
const CanvasHeader = ({ chatflow, isPublishedVersion }) => {
    return (
        <>
            <Typography>
                {flowName}
            </Typography>
            
            {/* ✅ 简洁的视觉提示 */}
            {isPublishedVersion && (
                <Box sx={{ display: 'flex', alignItems: 'center' }}>
                    <Lock 
                        size={14} 
                        strokeWidth={2} 
                        color={theme.palette.primary.main}  // 自适应主题
                    />
                </Box>
            )}

            {/* ✅ 条件渲染编辑按钮 */}
            {handleSaveFlow && (
                <Button onClick={onSaveChatflowClick}>保存</Button>
            )}
            
            {onPublishDraft && (
                <Button onClick={onPublishDraft}>发布</Button>
            )}
        </>
    )
}
```

**视觉设计演进：**

```
V1: 复杂版本
┌─────────────────────┐
│ 🔒 只读             │  背景色 + 边框 + 文字
└─────────────────────┘

V2: 简化版本
🔒 只读                  去掉背景和边框

V3: 极简版本 ✅
🔒                      只保留图标
```

**设计原则：Less is More**
- ✅ 极简设计，一个图标胜过千言万语
- ✅ 使用主题色，自动适配明暗模式
- ✅ 位置合理，紧跟Agent名称

### 4. 编辑对话框保护

```javascript
// EditNodeDialog.jsx
const EditNodeDialog = ({ dialogProps }) => {
    const [isReadOnly, setIsReadOnly] = useState(false)

    useEffect(() => {
        if (dialogProps.isReadOnly) {
            setIsReadOnly(true)
        }
    }, [dialogProps])

    return (
        <>
            {/* ✅ 隐藏名称编辑按钮 */}
            {data?.id && !isReadOnly && (
                <IconButton onClick={() => setEditingNodeName(true)}>
                    <IconPencil />
                </IconButton>
            )}

            {/* ✅ 禁用所有输入 */}
            <NodeInputHandler
                disabled={dialogProps.disabled || isReadOnly}
                inputParam={inputParam}
                data={data}
            />
        </>
    )
}
```

---

## 设计决策

### 决策1: 复制按钮是否保留？

```
❌ 初始方案：保留复制，禁用删除
   理由：用户可能需要复制已发布版本
   问题：UI不一致，用户困惑

✅ 最终方案：都隐藏
   理由：已发布版本应完全只读
   优势：UI清晰，概念统一
```

### 决策2: 提示方式？

```
❌ 方案A：点击后弹窗提示
   问题：需要交互才知道，体验差

❌ 方案B：Tooltip悬停提示
   问题：依然需要用户尝试

✅ 方案C：直接隐藏 + 顶部锁图标
   优势：一眼就知道是只读
```

### 决策3: 侧边栏是否显示？

```
❌ 保留侧边栏：
   - 占用屏幕空间
   - 诱导用户尝试添加节点

✅ 隐藏侧边栏：
   - 节省空间
   - 强化只读概念
   - 自动调整画布宽度
```

### 决策4: 信息按钮是否保留？

```
✅ 保留信息按钮：
   - 查看节点详情是合理需求
   - 了解配置信息
   - 不涉及修改操作
```

---

## 代码示例

### 完整示例：节点右键菜单

```javascript
import { useSelector } from 'react-redux'
import { MenuItem, MenuList } from '@mui/material'

const NodeContextMenu = ({ data, onClose }) => {
    // 1. 获取状态
    const chatflow = useSelector((state) => state.canvas.chatflow)
    const isPublishedVersion = chatflow?.versionType === 'PUBLISH'
    
    // 2. 获取操作函数
    const { deleteNode, duplicateNode } = useContext(flowContext)
    
    // 3. 渲染菜单
    return (
        <MenuList sx={{ py: 0, px: 0 }}>
            {/* 条件渲染编辑功能 */}
            {!isPublishedVersion && (
                <MenuItem 
                    onClick={() => {
                        duplicateNode(data.id)
                        onClose()
                    }}
                    sx={{
                        '&:hover': {
                            backgroundColor: theme.palette.background.border
                        }
                    }}
                >
                    复制
                </MenuItem>
            )}
            
            {!isPublishedVersion && (
                <MenuItem 
                    onClick={() => {
                        deleteNode(data.id)
                        onClose()
                    }}
                    sx={{
                        '&:hover': {
                            backgroundColor: theme.palette.background.border
                        }
                    }}
                >
                    删除
                </MenuItem>
            )}
            
            {/* 查看功能始终可用 */}
            <MenuItem 
                onClick={() => {
                    setShowInfoDialog(true)
                    onClose()
                }}
                sx={{
                    '&:hover': {
                        backgroundColor: theme.palette.background.border
                    }
                }}
            >
                信息
            </MenuItem>
        </MenuList>
    )
}
```

### 完整示例：画布操作拦截

```javascript
const Canvas = () => {
    // 1. 状态获取
    const chatflow = useSelector((state) => state.canvas.chatflow)
    const isPublishedVersion = chatflow?.versionType === 'PUBLISH'
    const { t } = useI18n()
    const dispatch = useDispatch()
    
    // 2. 操作拦截
    const onConnect = useCallback((params) => {
        // 已发布版本：显示提示并阻止
        if (isPublishedVersion) {
            dispatch(enqueueSnackbarAction({
                message: t('messages.publishedVersionReadOnly'),
                options: {
                    key: new Date().getTime() + Math.random(),
                    variant: 'warning'
                }
            }))
            return
        }
        
        // 正常版本：执行连接逻辑
        if (!isValidConnection(params)) {
            return
        }
        setEdges((eds) => addEdge(params, eds))
    }, [isPublishedVersion, t, dispatch])
    
    const onDrop = useCallback((event) => {
        event.preventDefault()
        
        // 已发布版本：阻止拖拽
        if (isPublishedVersion) {
            dispatch(enqueueSnackbarAction({
                message: t('messages.publishedVersionReadOnly'),
                options: { variant: 'warning' }
            }))
            return
        }
        
        // 正常版本：添加节点
        const nodeData = JSON.parse(event.dataTransfer.getData('application/reactflow'))
        // ... 添加节点逻辑
    }, [isPublishedVersion, t, dispatch])
    
    // 3. 渲染
    return (
        <>
            {/* 条件渲染侧边栏 */}
            {!isPublishedVersion && <AddNodes />}
            
            <ReactFlow
                nodes={nodes}
                edges={edges}
                onConnect={onConnect}
                onDrop={onDrop}
                onDragOver={onDragOver}
                // 底层禁用
                nodesDraggable={!isPublishedVersion}
                nodesConnectable={!isPublishedVersion}
                deleteKeyCode={isPublishedVersion ? null : ['Delete', 'Backspace']}
                elementsSelectable={true}
            />
        </>
    )
}
```

---

## 最佳实践

### 1. 状态管理 ⭐⭐⭐⭐⭐

```javascript
// ✅ DO: 使用Redux单一数据源
const chatflow = useSelector((state) => state.canvas.chatflow)
const isPublishedVersion = chatflow?.versionType === 'PUBLISH'

// ❌ DON'T: 在组件内部维护状态
const [isPublishedVersion, setIsPublishedVersion] = useState(false)
useEffect(() => {
    if (chatflow?.versionType === 'PUBLISH') {
        setIsPublishedVersion(true)
    }
}, [chatflow])
```

**原因：**
- Redux确保状态一致性
- useSelector自动优化性能
- 避免重复判断逻辑

### 2. 防御性编程 ⭐⭐⭐⭐⭐

```javascript
// ✅ DO: 使用可选链
const isPublishedVersion = chatflow?.versionType === 'PUBLISH'

// ❌ DON'T: 假设对象一定存在
const isPublishedVersion = chatflow.versionType === 'PUBLISH'  // 可能报错
```

### 3. 用户体验 ⭐⭐⭐⭐⭐

```javascript
// ✅ DO: 操作时提供反馈
if (isPublishedVersion) {
    enqueueSnackbar({
        message: t('messages.publishedVersionReadOnly'),
        options: { variant: 'warning' }
    })
    return
}

// ❌ DON'T: 静默失败
if (isPublishedVersion) {
    return  // 用户不知道为什么没反应
}
```

### 4. UI设计 ⭐⭐⭐⭐⭐

```javascript
// ✅ DO: 条件渲染
{!isPublishedVersion && <DeleteButton />}

// ❌ DON'T: 复杂的禁用逻辑
<DeleteButton 
    disabled={isPublishedVersion}
    style={{
        opacity: isPublishedVersion ? 0.5 : 1,
        cursor: isPublishedVersion ? 'not-allowed' : 'pointer',
        // ... 更多样式
    }}
/>
```

### 5. 多层防护 ⭐⭐⭐⭐⭐

```javascript
// ✅ DO: 多层保护
// 第1层：UI拦截
if (isPublishedVersion) {
    showWarning()
    return
}

// 第2层：ReactFlow配置
<ReactFlow 
    nodesDraggable={!isPublishedVersion}
    nodesConnectable={!isPublishedVersion}
/>

// ❌ DON'T: 只依赖一层
<ReactFlow />  // 没有配置级别的保护
```

### 6. 国际化支持 ⭐⭐⭐⭐

```javascript
// ✅ DO: 使用国际化
const { t } = useI18n()
message: t('messages.publishedVersionReadOnly')

// ❌ DON'T: 硬编码文案
message: '已发布版本为只读模式，无法编辑'
```

### 7. 主题适配 ⭐⭐⭐⭐

```javascript
// ✅ DO: 使用主题色
<Lock color={theme.palette.primary.main} />

// ❌ DON'T: 硬编码颜色
<Lock color="#3C89E8" />
```

---

## 常见问题

### Q1: 为什么不在后端拦截？

**A:** 前后端都需要！

```
前端拦截：
✅ 响应快
✅ 即时反馈
✅ 减少网络请求
✅ 更好的用户体验

后端拦截：
✅ 安全兜底
✅ 防止API绕过
✅ 数据完整性保护
```

**建议：** 前端提供体验，后端确保安全

### Q2: 复制功能要不要保留？

**A:** 根据业务场景决定

```
保留复制：
✅ 用户可以复制已发布版本创建草稿
✅ 有利于迭代开发
❌ 菜单项不一致

隐藏复制：
✅ UI清晰一致
✅ 完全只读概念
❌ 用户需要先切换到草稿版本
```

**本项目选择：** 隐藏（保持一致性）

### Q3: 如何处理用户不知道为什么不能编辑？

**A:** 多重提示

```
1. 视觉提示：顶部锁图标
2. 操作反馈：尝试编辑时显示警告
3. 帮助文档：说明已发布版本的特性
```

### Q4: 性能会有影响吗？

**A:** 几乎无影响

```javascript
// useSelector会自动优化
const chatflow = useSelector((state) => state.canvas.chatflow)

// 只在chatflow变化时重新计算
const isPublishedVersion = chatflow?.versionType === 'PUBLISH'
```

### Q5: 如何测试只读模式？

**测试清单：**

```markdown
[ ] 拖拽节点 - 应该无法移动
[ ] 连接节点 - 应该显示警告
[ ] 双击节点 - 应该显示警告
[ ] 键盘删除 - 应该无效
[ ] 右键菜单 - 只显示"信息"
[ ] 侧边栏 - 应该隐藏
[ ] 保存按钮 - 应该隐藏
[ ] 锁图标 - 应该显示
[ ] 切换版本 - 功能应该恢复
```

---

## 思维导图

```
只读模式实现
├─ 1. 需求分析
│  ├─ 业务场景：保护生产环境
│  ├─ 用户需求：清晰的只读提示
│  └─ 技术要求：全面的编辑禁用
│
├─ 2. 架构设计
│  ├─ 状态管理：Redux单一数据源
│  ├─ 判断逻辑：versionType === 'PUBLISH'
│  └─ 防护策略：三层保护
│
├─ 3. 实现方案
│  ├─ 画布层：操作拦截 + 底层禁用
│  ├─ 节点层：条件渲染菜单
│  ├─ 工具栏：隐藏编辑按钮 + 锁图标
│  └─ 对话框：禁用所有输入
│
├─ 4. 用户体验
│  ├─ 视觉提示：锁图标
│  ├─ 操作反馈：警告提示
│  └─ UI简洁：隐藏不可用功能
│
└─ 5. 质量保证
   ├─ 防御性编程：可选链
   ├─ 多层防护：不依赖单一防线
   ├─ 国际化：支持多语言
   └─ 主题适配：自动适配明暗模式
```

---

## 学习要点总结

### 🎯 核心理念

1. **单一数据源**
   - 状态集中管理
   - 避免不一致

2. **防御性编程**
   - 可选链保护
   - 边界情况处理

3. **用户体验优先**
   - 清晰的视觉提示
   - 友好的错误反馈
   - 简洁的UI设计

4. **多层防护**
   - UI层拦截
   - 底层配置
   - 后端验证

5. **极简主义**
   - Less is More
   - 只保留必要元素
   - 不断优化简化

### 📚 可复用的模式

```javascript
// 模式1: 状态驱动UI
const isXXX = useSelector(...)
{!isXXX && <Component />}

// 模式2: 操作拦截
const handleAction = () => {
    if (shouldBlock) {
        showWarning()
        return
    }
    // 正常逻辑
}

// 模式3: 多层防护
// UI层 + 配置层 + 后端层

// 模式4: 渐进式优化
// V1: 实现功能
// V2: 优化体验
// V3: 极简设计
```

---

## 结语

这个功能的实现展示了从**需求分析** → **架构设计** → **代码实现** → **持续优化**的完整过程。

**核心价值：**
- ✅ 清晰的思考框架
- ✅ 可复用的代码模式
- ✅ 优秀的用户体验
- ✅ 高质量的代码实现

**适用场景：**
- 只读模式实现
- 权限控制
- 状态驱动UI
- 多层防护设计

希望这份文档能帮助你理解**如何设计和实现一个高质量的功能**！

---

**文档版本：** v1.0  
**最后更新：** 2025-10-29  
**作者：** Agent Factory Team

# 已发布Agent只读保护功能实现文档

## 功能概述
当Agent已经发布（`versionType === 'PUBLISH'`）后，系统将自动启用只读保护模式，防止对已发布版本进行任何编辑操作。

## 实现的功能点

### 1. 画布编辑操作禁用
**文件**: `packages/ui/src/views/agentflowsv2/Canvas.jsx`

- ✅ **禁止连接节点**: 已发布版本不能创建新的节点连接
- ✅ **禁止拖拽添加节点**: 不能从侧边栏拖拽添加新节点到画布
- ✅ **禁止双击编辑节点**: 双击节点时显示警告提示，不打开编辑对话框
- ✅ **禁止拖拽移动节点**: 设置 `nodesDraggable={!isPublishedVersion}`
- ✅ **禁止删除节点（键盘）**: 设置 `deleteKeyCode` 在已发布版本时为 `null`
- ✅ **禁止修改连接**: 设置 `nodesConnectable={!isPublishedVersion}`
- ✅ **禁止标记为脏状态**: 已发布版本的修改不会触发"未保存更改"提示

### 1.5 节点右键菜单保护
**文件**: 
- `packages/ui/src/views/agentflowsv2/AgentFlowNode.jsx`
- `packages/ui/src/views/agentflowsv2/IterationNode.jsx`
- `packages/ui/src/views/agentflowsv2/StickyNote.jsx`

- ✅ **隐藏复制和删除按钮**: 已发布版本时直接不显示这两个按钮
- ✅ **只保留信息按钮**: 允许用户查看节点详细信息
- ✅ **简洁清晰**: 不需要任何提示，用户一眼就知道是只读模式

### 2. 节点编辑对话框只读模式
**文件**: `packages/ui/src/views/agentflowsv2/EditNodeDialog.jsx`

- ✅ **禁用节点名称编辑**: 隐藏节点名称编辑按钮
- ✅ **禁用参数输入**: 所有输入字段设置为 `disabled` 状态
- ✅ **接收只读属性**: 通过 `dialogProps.isReadOnly` 接收只读标志

### 3. 侧边栏节点管理
**文件**: `packages/ui/src/views/agentflowsv2/Canvas.jsx`

- ✅ **隐藏添加节点侧边栏**: 已发布版本完全隐藏侧边栏
- ✅ **自动调整画布宽度**: 画布自动占满全屏（不预留侧边栏空间）

### 4. 顶部工具栏调整
**文件**: `packages/ui/src/views/canvas/CanvasHeader.jsx`

- ✅ **隐藏保存按钮**: 已发布版本不显示保存按钮
- ✅ **隐藏删除按钮**: 已发布版本不显示删除按钮
- ✅ **隐藏存档按钮**: 已发布版本不显示存档按钮
- ✅ **隐藏发布按钮**: 已发布版本不显示发布按钮
- ✅ **显示只读标签**: 在Agent名称旁边显示蓝色的"只读"标签，带锁图标

### 5. 国际化支持
**文件**: 
- `packages/ui/src/i18n/locales/zh/agentcanvas.json`
- `packages/ui/src/i18n/locales/en/agentcanvas.json`

- ✅ **中文支持**: 添加了"只读"标签和"已发布版本为只读模式，无法编辑"提示消息
- ✅ **英文支持**: 添加了"Read Only"标签和"Published version is read-only and cannot be edited"提示消息

## 用户体验

### 已发布版本的特征
1. **视觉提示**: 在Agent名称旁边显示醒目的蓝色"只读"标签
2. **操作反馈**: 任何编辑操作（连接、拖拽、双击等）都会显示警告提示
3. **简洁界面**: 自动隐藏所有编辑相关的按钮和侧边栏
4. **无脏状态**: 不会出现未保存更改的提示

### 如何切换回可编辑状态
要编辑已发布的Agent，需要：
1. 在版本历史中切换回草稿版本（`versionType === 'DRAFT'`）
2. 或者创建新的草稿版本进行编辑

## 技术实现细节

### 判断逻辑
```javascript
const isPublishedVersion = chatflow?.versionType === 'PUBLISH'
```

### 关键代码位置

#### Canvas.jsx - 第112-120行
```javascript
// 判断是否为已发布版本
const isPublishedVersion = chatflow?.versionType === 'PUBLISH'

// 已发布版本时清除dirty状态
useEffect(() => {
    if (isPublishedVersion && canvasDataStore.isDirty) {
        dispatch({ type: REMOVE_DIRTY })
    }
}, [isPublishedVersion, canvasDataStore.isDirty, dispatch])
```

#### Canvas.jsx - 第1251-1258行
```javascript
deleteKeyCode={canvas.canvasDialogShow || isPublishedVersion ? null : ['Delete', 'Backspace']}
minZoom={0.5}
snapGrid={[25, 25]}
snapToGrid={isSnappingEnabled}
connectionLineComponent={ConnectionLine}
nodesDraggable={!isPublishedVersion}
nodesConnectable={!isPublishedVersion}
elementsSelectable={true}
```

#### CanvasHeader.jsx - 第649-673行
```javascript
{isPublishedVersion && (
    <Box
        sx={{
            display: 'flex',
            alignItems: 'center',
            gap: '4px',
            px: 1,
            py: 0.5,
            borderRadius: '4px',
            backgroundColor: customization.isDarkMode ? 'rgba(59, 130, 246, 0.2)' : 'rgba(59, 130, 246, 0.1)',
            border: `1px solid ${customization.isDarkMode ? 'rgba(59, 130, 246, 0.4)' : 'rgba(59, 130, 246, 0.3)'}`
        }}
    >
        <IconLock size={14} color={customization.isDarkMode ? '#60A5FA' : '#3B82F6'} />
        <Typography
            sx={{
                fontSize: '12px',
                fontWeight: 500,
                color: customization.isDarkMode ? '#60A5FA' : '#3B82F6'
            }}
        >
            {t('canvasHeader.labels.readOnly')}
        </Typography>
    </Box>
)}
```

## 测试建议

### 功能测试
1. ✅ 发布一个Agent，确认状态变为 `PUBLISH`
2. ✅ 尝试拖拽节点 - 应该无法移动
3. ✅ 尝试拖拽新节点到画布 - 应该显示警告
4. ✅ 尝试双击节点 - 应该显示警告
5. ✅ 尝试连接两个节点 - 应该显示警告
6. ✅ 尝试删除节点（Delete键）- 应该无效
7. ✅ 检查顶部工具栏 - 保存/删除/存档/发布按钮应该隐藏
8. ✅ 检查侧边栏 - 添加节点侧边栏应该隐藏
9. ✅ 检查只读标签 - 应该显示在Agent名称旁边

### 版本切换测试
1. 从已发布版本切换到草稿版本 - 应该恢复所有编辑功能
2. 从草稿版本切换到已发布版本 - 应该进入只读模式

## 相关文件清单

### 修改的文件
1. `/packages/ui/src/views/agentflowsv2/Canvas.jsx` - 主画布组件
2. `/packages/ui/src/views/agentflowsv2/EditNodeDialog.jsx` - 节点编辑对话框
3. `/packages/ui/src/views/canvas/CanvasHeader.jsx` - 顶部工具栏
4. `/packages/ui/src/views/agentflowsv2/AgentFlowNode.jsx` - 节点右键菜单
5. `/packages/ui/src/views/agentflowsv2/IterationNode.jsx` - 迭代节点右键菜单
6. `/packages/ui/src/views/agentflowsv2/StickyNote.jsx` - 便签节点右键菜单
7. `/packages/ui/src/store/context/ReactFlowContext.jsx` - 增强context传递状态
8. `/packages/ui/src/i18n/locales/zh/agentcanvas.json` - 中文国际化
9. `/packages/ui/src/i18n/locales/en/agentcanvas.json` - 英文国际化

### 涉及的数据库字段
- `ChatFlow.versionType` - 版本类型枚举 ('DRAFT' | 'ARCHIVE' | 'PUBLISH')

## 完成状态
✅ 所有功能已实现并通过lint检查，无任何错误。

